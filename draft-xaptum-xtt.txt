



Network Working Group                                        Z. Beckwith
Internet-Draft                                                   D. Bild
Intended status: Informational                              Xaptum, Inc.
Expires: November 9, 2017                                   May 08, 2017


         The Xaptum Trusted Transit (XTT) Protocol Version 1.0
                        draft-xaptum-xtt-latest

Abstract

   This document specifies version 1.0 of the Xaptum Trusted Transit
   (XTT) protocol for securing the Internet of Things (IoT).  It
   provides scalable identitiy provisioning, device authentication, and
   data integrity and confidentiality.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on November 9, 2017.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




Beckwith & Bild         Expires November 9, 2017                [Page 1]

Internet-Draft                     XTT                          May 2017


   This document may not be modified, and derivative works of it may not
   be created, and it may not be published except as an Internet-Draft.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Conventions and Terminology . . . . . . . . . . . . . . .   4
     1.2.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . .   5
     1.3.  Security Requirements for the IoT . . . . . . . . . . . .   5
       1.3.1.  Differences from (D)TLS . . . . . . . . . . . . . . .   5
       1.3.2.  Differences from QUIC . . . . . . . . . . . . . . . .   5
       1.3.3.  Differences from IKE/IPSec  . . . . . . . . . . . . .   5
       1.3.4.  Differences from Double-Ratchet-based Protocols . . .   6
       1.3.5.  Differences from Noise  . . . . . . . . . . . . . . .   6
       1.3.6.  Differences from MinimaLT . . . . . . . . . . . . . .   6
   2.  Protocol Overview . . . . . . . . . . . . . . . . . . . . . .   6
   3.  Handshake Protocols . . . . . . . . . . . . . . . . . . . . .   9
     3.1.  Features Common to All Handshakes . . . . . . . . . . . .   9
       3.1.1.  ClientInit Message  . . . . . . . . . . . . . . . . .  10
       3.1.2.  ServerInitAndAttest . . . . . . . . . . . . . . . . .  10
     3.2.  Identity Provisioning Protocol  . . . . . . . . . . . . .  11
       3.2.1.  ClientIdentity_ClientAttest . . . . . . . . . . . . .  11
     3.3.  Session Establishment Protocol  . . . . . . . . . . . . .  12
       3.3.1.  Session_ClientAttest  . . . . . . . . . . . . . . . .  12
   4.  Record Protocol . . . . . . . . . . . . . . . . . . . . . . .  12
   5.  Error Handling  . . . . . . . . . . . . . . . . . . . . . . .  13
   6.  Cryptographic Computations  . . . . . . . . . . . . . . . . .  13
     6.1.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .  13
     6.2.  Handshake Contexts  . . . . . . . . . . . . . . . . . . .  13
     6.3.  Key Calculation and Schedule  . . . . . . . . . . . . . .  13
     6.4.  SessionID Generation  . . . . . . . . . . . . . . . . . .  13
     6.5.  ECDHE Parameters  . . . . . . . . . . . . . . . . . . . .  13
     6.6.  Signature Algorithms  . . . . . . . . . . . . . . . . . .  13
     6.7.  Per-message Nonce Calculation . . . . . . . . . . . . . .  13
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  14
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  14
   Appendix A.  State Machine  . . . . . . . . . . . . . . . . . . .  15
     A.1.  Identity Provisioning Handshake . . . . . . . . . . . . .  15
       A.1.1.  Client  . . . . . . . . . . . . . . . . . . . . . . .  15
       A.1.2.  Server  . . . . . . . . . . . . . . . . . . . . . . .  15
     A.2.  Session Establishment Handshake . . . . . . . . . . . . .  15
       A.2.1.  Client  . . . . . . . . . . . . . . . . . . . . . . .  15
       A.2.2.  Server  . . . . . . . . . . . . . . . . . . . . . . .  15
   Appendix B.  Presentation Language  . . . . . . . . . . . . . . .  16
     B.1.  Miscellaneous . . . . . . . . . . . . . . . . . . . . . .  16
     B.2.  Definition of Byte  . . . . . . . . . . . . . . . . . . .  16
     B.3.  Byte Arrays . . . . . . . . . . . . . . . . . . . . . . .  16



Beckwith & Bild         Expires November 9, 2017                [Page 2]

Internet-Draft                     XTT                          May 2017


     B.4.  Numeric Data  . . . . . . . . . . . . . . . . . . . . . .  16
     B.5.  Enumerateds . . . . . . . . . . . . . . . . . . . . . . .  17
     B.6.  Constructed Types . . . . . . . . . . . . . . . . . . . .  18
     B.7.  AEAD-Encrypted Constructed Types  . . . . . . . . . . . .  18
     B.8.  Constants . . . . . . . . . . . . . . . . . . . . . . . .  19
     B.9.  Variants  . . . . . . . . . . . . . . . . . . . . . . . .  19
   Appendix C.  Protocol Data Structures and Constant Values . . . .  20
     C.1.  Common Message Header . . . . . . . . . . . . . . . . . .  20
     C.2.  Handshakes  . . . . . . . . . . . . . . . . . . . . . . .  20
       C.2.1.  DAA Types . . . . . . . . . . . . . . . . . . . . . .  21
       C.2.2.  Server Certificates . . . . . . . . . . . . . . . . .  21
     C.3.  Record Layer  . . . . . . . . . . . . . . . . . . . . . .  22
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  22

1.  Introduction

   DISCLAIMER: This is a WIP draft and has not yet seen significant
   security analysis.

   The primary goal of the XTT protocol is to provide a secure
   communication channel between an Internet of Things (IoT) device in
   the field and a backend network or server.  The nature of the IoT
   imposes several constraints different from traditional transport
   layer security:

   -  Identity Provisioning: IoT devices will be numerous and must be
      low-cost, so manual provisioning of preshared keys (PSKs) or
      client certificates will not scale.  Instead, devices must be
      provisioned long-term cryptographic identities in the field on
      first use.  XTT leverages the Direct Anonymous Attestation {DAA}
      capabilties of modern processors to enable this.

   -  IP Address Mobility: The last-mile Internet access can change
      frequently for IoT devices.  Needing to reestablish the secure
      channel after every IP address change is bad for energy- and
      bandwidth-constrained devices.  XTT decouples the secure channel
      from the underlying TCP or UDP transport socket.

   -  DoS Resistance: The secure communication channel is established
      over the public Internet, so the protocol must be designed to help
      the server-side resist denial of service (DoS) attacks.

   The protocol must also provide the following traditional security
   properties:

   -  Mutual Authentication: Both the client and server sides are always
      authenticated.  Server authentication happens via ECDSA and client
      authentication happens via PSK or DAA.



Beckwith & Bild         Expires November 9, 2017                [Page 3]

Internet-Draft                     XTT                          May 2017


   -  Integrity: Data sent over the channel cannot be modified by an
      attacker.

   -  Confidentiality: Data sent over the channel is visible only to the
      endpoints.  This property is optional; encryption may be disabled
      if the channel is tunneling data that was already encrypted.

   The protocol must resist an attacker with complete control of the
   network, as described in [RFC3552].

   XTT consists of three primary components:

   -  An identity provisioning protocol (Section 3.2) that (TODO) (1
      par.) describe this protocol

   -  A session establishment protocol (Section 3.3) that (TODO) (1
      par.) describe this protocol

   -  A record protocol (Section 4) that (TODO) (1 par.) describe this
      protocol

1.1.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in RFC
   2119 [RFC2119].

   The following terms are used:

   client: (TODO) (1 sent.)

   endpoint: (TODO) (1 sent.)

   handshake: (TODO) (1 sent.)

   identity: (TODO) (1 sent.)

   receiver: (TODO) (1 sent.)

   sender: (TODO) (1 sent.)

   server: (TODO) (1 sent.)

   session: (TODO) (1 sent.)






Beckwith & Bild         Expires November 9, 2017                [Page 4]

Internet-Draft                     XTT                          May 2017


1.2.  Use Cases

   (TODO)

1.3.  Security Requirements for the IoT

   (TODO) How IoT security differs from old world.  What are the unique
   requirements.

1.3.1.  Differences from (D)TLS

   -  Heavyweight (heavy use of bandwidth during handshake)

   -  Designed around one-way, not mutual, authentication

   -  Non-confidential communication of identities during handshake

   -  Security session tied to connectivity session

      o  Having to re-run handshake every time underlying connection/IP
         changes compounds bandwidth problem

   (TODO) (1 list) what (D)TLS doesn't offer that IoT requires

1.3.2.  Differences from QUIC

   -  Security session tied to connectivity session

   -  Not designed for mutual authentication

   (TODO) (1 list) what QUIC doesn't offer that IoT requires

1.3.3.  Differences from IKE/IPSec

   -  Pushing data requires performing full Two-Round-Trip handshake
      first

   -  Protects identity of server, not client, which is the opposite of
      what's needed in IoT

   -  Very complex to configure, and easy to get wrong

   (TODO) (1 list) what IKE doesn't offer that IoT requires








Beckwith & Bild         Expires November 9, 2017                [Page 5]

Internet-Draft                     XTT                          May 2017


1.3.4.  Differences from Double-Ratchet-based Protocols

   -  Per-message key updating is too heavy for most IoT, which doesn't
      require per-message forward secrecy

   -  Doesn't address identification (uses trust on first use)

   (TODO) (1 list) what Double-Ratchet doesn't offer that IoT requires

1.3.5.  Differences from Noise

   -  Designed mainly for either pre-shared (or statically-known) keys,
      or for unauthenticated communication

   (TODO) (1 list) what Noise doesn't offer that IoT requires

1.3.6.  Differences from MinimaLT

   -  Requires a highly-available directory service for name-lookup
      (unnecessary in IoT)

   -  Reliable-transport only (can cause issues on lossy networks
      commonly encountered in IoT)

   -  User-level authentication is inappropriate for IoT (devices aren't
      multi-user)

   (TODO) (1 list) what MinimalLT doesn't offer that IoT requires

2.  Protocol Overview

   An XTT session is started using one of two related but distinct
   handshake protocols: one to create an Authenticated Session, and
   another to both create an Authenticated Session and provision a
   ClientID to the client.  Running an Authenticated Session handshake
   requires that a ClientID handshake has successfully been performed at
   least once previously.

   The ClientID handshake is used to authenticate both parties as being
   members of recognized and permissioned groups.  The typical case is
   of a client proving membership in a group permissioned to access a
   private network, and a server proving membership in the group of
   access points for that network.  Upon successful completion of a
   ClientID handshake, the server provisions to the client a ClientID, a
   unique identifier within the client's group.  In addition, the client
   and server have now negotiated shared secret material that can be
   used for future authentication, without requiring the public-
   cryptography-based authentication of the ClientID handshake.



Beckwith & Bild         Expires November 9, 2017                [Page 6]

Internet-Draft                     XTT                          May 2017


   Note that the lifetime of a given ClientID, i.e. the time between
   successive ClientID handshakes, is up to the discretion of the
   client.  It is possible for a given physical endpoint to perform a
   ClientID handshake only once (due to, for example, hardware
   constraints the preclude the required signatures) and retain the same
   ClientID for its entire lifetime.  Conversely, a client that does not
   wish its messages to be linkable by passive attackers may perform a
   ClientID handshake as often as every message; in fact, by using
   anonymized signature algorithms (e.g.  Direct Anonymous Attestation),
   a client may keep active attackers and even the server from being
   able to link its messages to one another.

   The XTT AuthenticatedSession handshake can be performed after (or at
   the same time as) a successful ClientID handshake.  The
   AuthenticatedSession handshake leverages existing secret material
   shared between the client and server to generate shared secret
   cryptographic keys, to be used for encrypting and authenticating
   subsequent messages.

   Both XTT handshake protocols are based on the SigMA family of
   authenticated key exchange protocols, which is also the basis for
   signature-based authentication in the Internet Key Exchange version 2
   (IKEv2) protocol [RFC7296] used in the IPSec protocol suite.
   Specifically, the XTT protocol uses the SigMA-I variant described in
   [SIGMA].  In particular, note that the present protocol does not
   place the MAC under the signature, as is done in IKEv2 (this is
   referred to as variant (ii) in [SIGMA]).  A formal security analysis
   of the SigMA protocols can be found in [SIGMASEC].

   The handshake protocols are authenticated Diffie-Hellman key
   exchanges.  Both protocols require three messages, and only one full
   round-trip (1 RTT) before a client can begin pushing traffic.  The
   client, who is always the initiator of a handshake, may choose to
   begin pushing traffic with the third message, before receiving the
   final response from the server.  The reason for requiring 1 RTT (in
   distinction to the 0-RTT option proposed for the upcoming TLSv1.3
   standard) is to protect against replay attacks.  The handshake
   protocol protects the confidentiality of the client's identity from
   both passive and active attackers, while protecting the server's
   identity from passive attackers (this isn't an issue in IoT, as the
   server's identity is usually known).

   (TODO) Specific handshake design aspects * Small, fixed-size messages
   during handshake * No arbitrary-length certificate chains

         Client                                             Server
         -----------------------             -----------------------




Beckwith & Bild         Expires November 9, 2017                [Page 7]

Internet-Draft                     XTT                          May 2017


          CLIENTINIT
          + version
          + crypto-spec
          + session_id_seed_c
          + signing nonce
          + ECDHE public key      ------->

                                              SERVERINITANDATTEST ^ < Hk
                                                        version + |
                                                    crypto-spec + |
                                              session_id_seed_c + |
                                               ECDHE public key + |
                                                  {certificate} + |
                                            {session_id_seed_s} + |
                                                    {signature} + |
                                  <-------      {server cookie} + v

   Hk > ^ CLIENTATTEST
        | + {DAA group key}
        | + ({identity request})
        v + {DAA signature}
   Sk > ^
        | + ([Application Data])  ------->
        v

                                                                  ^ < Sk
                                                 (SERVERFINISHED) |
                                  <------- ([identity confirm]) + |
                                                                  v

   Sk > ^                                                         ^ < Sk
        |  RECORDREGULAR                            RECORDREGULAR |
        |  + [Application Data]   <------>   [Application Data] + |
        v                                                         v

               +  Indicates message subfields

               () Indicates optional messages/subfields

               {} Indicates data encrypted using handshake keys

               [] Indicates data encrypted using session keys

          Hk > ^
               | Indicates data MAC'd using handshake keys
               v

          Sk > ^



Beckwith & Bild         Expires November 9, 2017                [Page 8]

Internet-Draft                     XTT                          May 2017


               | Indicates data MAC'd using session keys
               v

      Figure 1: Message flow for XTT Identity Provisioning Handshake

         Client                                                Server
        ^ ClientInit
        | + version and crypto-spec
        | + ECDHE public key
        v + session id seed          ------->

                                                 ServerInitAndAttest ^
                                           version and crypto-spec + |
                                                  ECDHE public key + |
                                                     {certificate} + |
                                                 {session id seed} + |
                                                       {signature} + v
                                     <-------
        ^  ClientAttest
        | + {identity}
        | + {psk signature}
        v * [Application Data]       ------->
                                     <------        ServerFinished *

          [Application Data]         <------>     [Application Data]

               +  Indicates message subfields

               *  Indicates optional subfields/messages

               {} Indicates messages protected using
                  handshake keys

               [] Indicates messages protected using
                  session keys

         Figure 2: Message flow for XTT Session Creation Handshake

   (TODO) record layer

3.  Handshake Protocols

3.1.  Features Common to All Handshakes

   The first two messages of a handshake (ClientInit and
   ServerInitAndAttest) are the same for both handshake types (ClientID
   and AuthenticatedSession).  When responding to a ClientInit with a
   ServerInitAndAttest, an implementation MAY store all necessary state



Beckwith & Bild         Expires November 9, 2017                [Page 9]

Internet-Draft                     XTT                          May 2017


   in the ServerCookie embedded in the ServerInitAndAttest and save no
   state locally.

   After receiving a ServerInitAndAttest, a client responds with a
   ClientAttest message.  There are four variants of ClientAttest
   message, where two are for a ClientID handshake and two are for an
   AuthenticatedSession handshake.  For each handshake type, the two
   variants indicate whether or not a payload is included with the
   message.

3.1.1.  ClientInit Message

   All handshakes begin with the client sending a ClientInit message to
   the server.  A client may resend a ClientInit if it has not received
   a ServerInitAndAttest in response within a timeout period.  There is
   no requirement that ClientInit retries be identical, as long as a
   client only responds to one ServerInitAndAttest response.

   Structure of this message:

   struct {
       MsgType type = client_init;
       Version version;
       SuiteSpec spec;
       SessionIDSeed session_id_seed;
       SigningNonce client_nonce;
       DHKeyShare client_dh_keyshare;
   } ClientInit;

3.1.2.  ServerInitAndAttest

   Structure of this message:

   aead_struct<handshake_keys>(
       MsgType type = server_init_and_attest;
       Version version;
       SuiteSpec spec;
       SessionIDSeed session_id_seed;   /* echo from client */
       DHKeyShare server_dh_keyshare;
   )[
       ServerCertificate certificate;
       SessionIDSeed session_id_seed;
       ServerSignature server_signature;
       ServerCookie server_cookie;
   ] ServerInitAndAttest;






Beckwith & Bild         Expires November 9, 2017               [Page 10]

Internet-Draft                     XTT                          May 2017


3.2.  Identity Provisioning Protocol

   This handshake provisions a ClientID to a client and simultaneously
   creates an AuthenticatedSession.

3.2.1.  ClientIdentity_ClientAttest

   aead_struct<handshake_keys>(
       MsgType type =  MsgType.id_clientattest_nopayload;
       Version version;
       SuiteSpec spec;
       byte flags[1];
       ServerCookie server_cookie;     /* echo from server */
   }[
       DAAGroupKey daa_gpk;
       ClientID id;
       DAASignature signature;
   ] ClientIdentity_ClientAttest_NoPayload;

   struct {
       aead_struct<handshake_keys>(
           MsgType type = MsgType.id_clientattest_payload;
           Version version;
           SuiteSpec spec;
           byte flags[1];
           ServerCookie server_cookie;     /* echo from server */
       }[
           DAAGroupKey daa_gpk;
           ClientID id;
           DAASignature signature;
       ];
       aead_struct<session_keys>(
           MsgLength length;               /* total length */
       )[
           EncapsulatedPayloadType payload_type;
           byte payload[length - sizeof(rest_of_message)];
       ];
   } ClientIdentity_ClientAttest_Payload;

   aead_struct<session_keys>(
       MsgType type = MsgType.id_serverfinished;
       Version version;
       SuiteSpec spec;
   )[
       ClientID client_id;     /* confirm id of client */
       FinishedContext ctx;
   ] ClientIdentity_ServerFinished;




Beckwith & Bild         Expires November 9, 2017               [Page 11]

Internet-Draft                     XTT                          May 2017


3.3.  Session Establishment Protocol

3.3.1.  Session_ClientAttest

   aead_struct<handshake_keys>(
       MsgType type =  MsgType.session_clientattest_nopayload;
       Version version;
       SuiteSpec spec;
       byte flags[1];
       ServerCookie server_cookie;     /* echo from server */
   }[
       ClientID id;
       PSKSignature signature;
   ] AuthenticatedSession_ClientAttest_NoPayload;

   struct {
       aead_struct<handshake_keys>(
           MsgType type = MsgType.session_clientattest_payload;
           Version version;
           SuiteSpec spec;
           byte flags[1];
           ServerCookie server_cookie;     /* echo from server */
       }[
           ClientID id;
           PSKSignature signature;
       ];
       aead_struct<session_keys>(
           MsgLength length;               /* total length */
       )[
           EncapsulatedPayloadType payload_type;
           byte payload[length - sizeof(rest_of_message)];
       ];
   } AuthenticatedSession_ClientAttest_Payload;

   aead_struct<session_keys>(
       MsgType type = MsgType.session_serverfinished;
       Version version;
       SuiteSpec spec;
   )[
       FinishedContext ctx;
   ] AuthenticatedSession_ServerFinished;

4.  Record Protocol








Beckwith & Bild         Expires November 9, 2017               [Page 12]

Internet-Draft                     XTT                          May 2017


   aead_struct<session_keys>(
       MsgType type = MsgType.record_regular;
       Version version;
       SessionID session_id;
       SequenceNumber seq_num;
       MsgLength length;
   )[
       EncapsulatedPayloadType payload_type;
       byte payload[length - sizeof(rest_of_message)];
   ] Record_Regular;

5.  Error Handling

   (TODO)

6.  Cryptographic Computations

6.1.  Notation

6.2.  Handshake Contexts

6.3.  Key Calculation and Schedule

6.4.  SessionID Generation

6.5.  ECDHE Parameters

   The size and interpretation of a value of type DHKeyShare depends on
   the Diffie-Hellman algorithm specified in the handshake messages.

   Currently, only x25519 is supported by the protocol.

   For x25519, the contents are the byte string inputs and outputs of
   the corresponding functions defined in [RFC7748].  The size of the
   DHKeyShare in this case is 32 bytes.

6.6.  Signature Algorithms

6.7.  Per-message Nonce Calculation

   (TODO)

7.  References








Beckwith & Bild         Expires November 9, 2017               [Page 13]

Internet-Draft                     XTT                          May 2017


7.1.  Normative References

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <http://www.rfc-editor.org/info/rfc5116>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <http://www.rfc-editor.org/info/rfc5869>.

   [RFC7539]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
              Protocols", RFC 7539, DOI 10.17487/RFC7539, May 2015,
              <http://www.rfc-editor.org/info/rfc7539>.

   [RFC7693]  Saarinen, M-J., Ed. and J-P. Aumasson, "The BLAKE2
              Cryptographic Hash and Message Authentication Code (MAC)",
              RFC 7693, DOI 10.17487/RFC7693, November 2015,
              <http://www.rfc-editor.org/info/rfc7693>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <http://www.rfc-editor.org/info/rfc7748>.

   [SHS]      National Institute of Standards and Technology, "Secure
              Hash Standard", NIST FIPS PUB 180-4, March 2012.

7.2.  Informative References

   [MINIMALT]
              Petullo, W., Zhang, X., Solworth, J., Bernstein, D., and
              T. Lange, "MinimalLT: Minimal-latency Networking Through
              Better Security", November 2013.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <http://www.rfc-editor.org/info/rfc3552>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.



Beckwith & Bild         Expires November 9, 2017               [Page 14]

Internet-Draft                     XTT                          May 2017


   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <http://www.rfc-editor.org/info/rfc6347>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <http://www.rfc-editor.org/info/rfc7296>.

   [SIGMA]    Krawczyk, H., "SIGMA: the 'SIGn-and-MAc' approach to
              authenticated Diffie-Hellman and its use in the IKE
              protocols", Proceedings of CRYPTO 2003 , June 2003.

   [SIGMASEC]
              Canetti, R. and H. Krawczyk, "Security Analysis of IKE's
              Signature-Based Key-Exchange Protocol", October 2002.

Appendix A.  State Machine

   This section provides a summary of the legal state machine
   transitions for the client and server handshakes.  State names (in
   all capitals, e.g., START) have no formal meaning, but are provided
   for ease of comprehension.  Messages which are sent only sometimes
   are indicated in "[]".  (TODO)

A.1.  Identity Provisioning Handshake

A.1.1.  Client

   (TODO)

A.1.2.  Server

   (TODO)

A.2.  Session Establishment Handshake

A.2.1.  Client

   (TODO)

A.2.2.  Server

   (TODO)







Beckwith & Bild         Expires November 9, 2017               [Page 15]

Internet-Draft                     XTT                          May 2017


Appendix B.  Presentation Language

B.1.  Miscellaneous

   Comments begin with "/*" and end with "*/".

   To indicate the number of bytes taken up in the byte stream by a type
   or value, the expression "sizeof(value-or-type)" is used.

   Optional components are denoted by enclosing them in "[[ ]]" double
   brackets.

B.2.  Definition of Byte

   One byte is defined to be 8 bits.  Multiple-byte data items are
   concatenations of bytes, from left to right, from top to bottom.

B.3.  Byte Arrays

   A byte-array is a single-dimensional array of bytes of given fixed
   length.  The syntax for specifying a new type, "Tp", that is a byte-
   array of length "n" is

   byte Tp[n];

   Here, "Tp" occupies "n" bytes in the data stream.  The length of the
   vector is not included in the encoded stream.

   An anonymous byte array is specified by not including a new type
   name: "byte[n]" indicates space of n bytes in the byte stream.  This
   is useful for constructed and variant types.

   Unless defined as a numeric data type, the bytes comprising a byte-
   array are not to be interpreted by the protocol in any way.

B.4.  Numeric Data

   A type defined as an n-byte numeric value indicates that the byte
   stream is interpreted (using C notation) as:

   numeric_value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
           ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.  The pre-defined numeric types
   uint8, uint16, uint32, and uint64 are defined as





Beckwith & Bild         Expires November 9, 2017               [Page 16]

Internet-Draft                     XTT                          May 2017


   byte uint8[1];
   byte uint16[2];
   byte uint32[4];
   byte uint64[8];

   For example, the uint32 value given by the bytestream "01 02 03 04"
   is interpreted as the decimal value 16909060.

B.5.  Enumerateds

   To indicate a type that may take values only from a fixed set of
   possible values, a new type may be defined as of type "enum".  Each
   definition of an enumerated type is a different type.  Only
   enumerateds of the same type may be assigned or compared.  Every
   element of an enumerated must be assigned a value.

   The possible values of an enumerated type are specified in this
   document using numeric values.  To indicate how to interpret a value
   of an enumerated type, and to indicate how much space in the byte
   stream is occupied by an enumerated type, the definition of the
   enumerated type includes the underlying numeric type used to define
   its values.

   Implementations that receive a value of an enumerated type that is
   not in the set of possible values for that type MUST reject the
   containing message and handle the error as specified for that message
   type.

   The following example defines an enumerated type called Color that
   has three possible values, which are represented in the byte stream
   as uint16 values (thus a value of type Color occupies 2 bytes in the
   byte stream)

   enum : uint16 {
       Red(0x1234),
       Green(9),
       Blue(60000)
   } Color;

   The names of the elements of an enumerated type are scoped within the
   defined type, and a reference in this document to the value of a name
   is always given by the fully-qualified form "Type.Name".  Thus a
   reference to the "Color" value "Blue" from above is given by
   "Color.Blue".







Beckwith & Bild         Expires November 9, 2017               [Page 17]

Internet-Draft                     XTT                          May 2017


B.6.  Constructed Types

   Complex types may be constructed from primitive types, using the
   "struct" construction.  Each constructed type defines a new type.

   The following example defines a constructed type called "T", which
   comprises two subfields "f1" and "f2"

   struct {
       T1 f1;
       T2 f2;
   } T;

   A value of type "T" would occupy a total of "sizeof(T1) + sizeof(T2)"
   bytes in the byte stream.

   Subfields of a constructed type are referenced in this document by
   "Type.subfield" when referring to the field in the general type
   "Type", and by "name.subfield" when referring to the field in a
   specific value named "name".  Thus, the value of the subfield "f2" in
   a value called "foo" of type "T", from the example above, would be
   referenced as "foo.f1".

B.7.  AEAD-Encrypted Constructed Types

   Encryption and authentication of all messages in this protocol are
   done using Authenticated Encryption with Additional Data (AEAD)
   [RFC5116].  To indicate that a constructed type is processed using an
   AEAD algorithm, the following notation is used:

   aead_struct<key_set>(
       addl1;
       addl2;
       ...
       addlN;
   )[
       enc1;
       enc2;
       ...
       encN;
   ] T;

   In this example, the type "T" consists of the unencrypted subfields
   "addl1" through "addlN", and the encrypted subfields "enc1" through
   "encN".  The keys (encryption key, authentication key, and nonce)
   used is given by "key_set".  The entire struct is authenticated.
   Note that the total length in the byte stream of a value of type "T"




Beckwith & Bild         Expires November 9, 2017               [Page 18]

Internet-Draft                     XTT                          May 2017


   is the size of an authentication tag (determined by the chosen AEAD
   algorithm) in addition to the sum of the sizes of its subfields.

B.8.  Constants

   Fields and variables may be assigned a fixed value using "=".  In the
   following example, all values of type "T" would always have "T.c"
   equal to "Color.Blue"

   struct {
       Color c = Color.Blue;
       T2 f2;
   } T;

B.9.  Variants

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  There
   must be a case arm for every element of the enumeration declared in
   the select.  Case arms have limited fall-through: if two case arms
   follow in immediate succession with no fields in between, then they
   both contain the same fields.

   The mechanism by which the variant is selected at runtime is not
   prescribed by the presentation language.

   For example:

   uint8 SubT1;
   uint16 SubT2;
   struct {
       select (color_in) {
           case Color.Red:
               SubT1;
           case Color.Green:
           case Color.Blue:
               SubT2;
       } variant_field;
   } VariantStruct;

   In this example, it is assumed the creation of a value of type
   "VariantStruct" requires the input of a parameter called "color_in"
   of type "Color".  When creating a value of type VariantStruct with
   name S, if "color_in" is "Red" then the subfield "S.variant_field" is
   of type "SubT1".  Alternatively, if "color_in" is either "Green" or
   "Blue", "S.variant_field" is of type "SubT2".  Note that the size of




Beckwith & Bild         Expires November 9, 2017               [Page 19]

Internet-Draft                     XTT                          May 2017


   the type "VariantStruct" depends on the value of "color_in" at the
   time of construction.

Appendix C.  Protocol Data Structures and Constant Values

   This section describes protocol types and constants.

C.1.  Common Message Header

   enum : uint8 {
       client_init(0x01),
       server_init_and_attest(0x02),
       id_clientattest_response_nopayload_ip(0x11),
       id_clientattest_response_payload_ip(0x12),
       id_clientattest_response_nopayload_noip(0x13),
       id_clientattest_response_payload_noip(0x14),
       id_clientattest_noresponse_payload_ip(0x15),
       id_clientattest_noresponse_payload_noip(0x16),
       id_serverfinished(0x17),
       session_clientattest_response_nopayload_ip(0x21),
       session_clientattest_response_payload_ip(0x22),
       session_clientattest_response_nopayload_noip(0x23),
       session_clientattest_response_payload_noip(0x24),
       session_clientattest_noresponse_payload_ip(0x25),
       session_clientattest_noresponse_payload_noip(0x26),
       session_serverfinished(0x27),
       record_regular(0x31),
       alert(0x41)
   } MsgType;

   enum : uint8 {
       one(1)
   } Version;

C.2.  Handshakes

   enum : uint16 {
       x25519_epid2_chacha20poly1305_sha512(1),
       x25519_epid2_chacha20poly1305_blake2b(2),
       x25519_epid2_aes256gcm_sha512(3),
       x25519_epid2_aes256gcm_blake2b(4),
       x25519_epid2_null_sha512(5),
       x25519_epid2_null_blake2b(6)
   } SuiteSpec;

   byte SessionIDSeed[8];

   byte SigningNonce[32];



Beckwith & Bild         Expires November 9, 2017               [Page 20]

Internet-Draft                     XTT                          May 2017


   byte ServerCookie[130];

   byte ClientID[16];

   byte LongtermSecret[64];

   select(dh_algorithm) {
       byte[<size of public key for this algorithm>];
   } DHKeyShare;

   enum : uint8 {
       Ed25519(1)
   } ServerSignatureType;

   select(server_signature_algorithm) {
       byte[<size of signature for this algorithm>];
   } ServerSignature;

   select(server_signature_algorithm) {
       byte[<size of public key for this algorithm>];
   } ServerSignaturePublicKey;

C.2.1.  DAA Types

   select(dh_algorithm) {
       byte[<size of group public key for this algorithm>];
   } DAAGroupKey;

   select(dh_algorithm) {
       byte[<size of signature for this algorithm>];
   } DAASignature;

C.2.2.  Server Certificates

   enum : uint8 {
       one(1)
   } ServerCertificateVersion;

   byte Date[8];   /* YYYYMMDD according to UTC */












Beckwith & Bild         Expires November 9, 2017               [Page 21]

Internet-Draft                     XTT                          May 2017


   struct {
       ServerCertificateVersion version;
       ServerSignatureType algorithm;
       Date expiry;
       ClientID id;
       ServerSignature signature;
       ServerIntermediateCertificate signers_certificate;
       ServerSignature signers_signature;
   } ServerCertificate;

   struct {
       ServerSignatureVersion version;
       ServerSignatureType algorithm;
       Date expiry;
       ServerSignaturePublicKey public_key;
       byte root_id[32];       /* ServerRootCertificate to use */
       ServerSignature root_signature;
   } ServerIntermediateCertificate;

   struct {
       ServerSignatureVersion version;
       ServerSignatureType algorithm;
       Date expiry;
       ServerSignaturePublicKey public_key;
       byte id[32];
   } ServerRootCertificate;

C.3.  Record Layer

   byte SessionID[16];

   uint32 SequenceNumber;

   uint16 MsgLength;

   enum : uint8 {
       queue_protocol(1),
       ipv6(2)
   } EncapsulatedPayloadType;

Authors' Addresses

   Zane Beckwith
   Xaptum, Inc.

   Email: zane.beckwith@xaptum.com





Beckwith & Bild         Expires November 9, 2017               [Page 22]

Internet-Draft                     XTT                          May 2017


   David R. Bild
   Xaptum, Inc.

   Email: david.bild@xaptum.com















































Beckwith & Bild         Expires November 9, 2017               [Page 23]
