<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Xaptum Trusted Transit (XTT) Protocol Version 1.0</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Use Cases"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Security Requirements for the IoT"/>
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Differences from (D)TLS"/>
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Differences from QUIC"/>
<link href="#rfc.section.1.3.3" rel="Chapter" title="1.3.3 Differences from IKE/IPSec"/>
<link href="#rfc.section.1.3.4" rel="Chapter" title="1.3.4 Differences from Double-Ratchet-based Protocols"/>
<link href="#rfc.section.1.3.5" rel="Chapter" title="1.3.5 Differences from Noise"/>
<link href="#rfc.section.1.3.6" rel="Chapter" title="1.3.6 Differences from MinimaLT"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Handshake Protocols"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Features Common to All Handshakes"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 ClientInit Message"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 ServerInitAndAttest"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Identity Provisioning Protocol"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 ClientIdentity_ClientAttest"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Session Establishment Protocol"/>
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Session_ClientAttest"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Record Protocol"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Error Handling"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Cryptographic Computations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Notation"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Handshake Contexts"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Key Calculation and Schedule"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 SessionID Generation"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 ECDHE Parameters"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Signature Algorithms"/>
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Per-message Nonce Calculation"/>
<link href="#rfc.references" rel="Chapter" title="7 References"/>
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A State Machine"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Identity Provisioning Handshake"/>
<link href="#rfc.appendix.A.1.1" rel="Chapter" title="A.1.1 Client"/>
<link href="#rfc.appendix.A.1.2" rel="Chapter" title="A.1.2 Server"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Session Establishment Handshake"/>
<link href="#rfc.appendix.A.2.1" rel="Chapter" title="A.2.1 Client"/>
<link href="#rfc.appendix.A.2.2" rel="Chapter" title="A.2.2 Server"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Presentation Language"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Miscellaneous"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Definition of Byte"/>
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Byte Arrays"/>
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Numeric Data"/>
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Enumerateds"/>
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Constructed Types"/>
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 AEAD-Encrypted Constructed Types"/>
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Constants"/>
<link href="#rfc.appendix.B.9" rel="Chapter" title="B.9 Variants"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Protocol Data Structures and Constant Values"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Common Message Header"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Handshakes"/>
<link href="#rfc.appendix.C.2.1" rel="Chapter" title="C.2.1 DAA Types"/>
<link href="#rfc.appendix.C.2.2" rel="Chapter" title="C.2.2 Server Certificates"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Record Layer"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Beckwith, Z. and D. Bild" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-xaptum-xtt-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-5-08" />
  <meta name="dct.abstract" content="This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality." />
  <meta name="description" content="This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">Z. Beckwith</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">D. Bild</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">Xaptum, Inc.</td>
</tr>
<tr>
  <td class="left">Expires: November 9, 2017</td>
  <td class="right">May 08, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Xaptum Trusted Transit (XTT) Protocol Version 1.0<br />
  <span class="filename">draft-xaptum-xtt-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 9, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may not be modified, and derivative works of it may not be created, and it may not be published except as an Internet-Draft.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Use Cases</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Security Requirements for the IoT</a></li>
<ul><li>1.3.1.   <a href="#rfc.section.1.3.1">Differences from (D)TLS</a></li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Differences from QUIC</a></li>
<li>1.3.3.   <a href="#rfc.section.1.3.3">Differences from IKE/IPSec</a></li>
<li>1.3.4.   <a href="#rfc.section.1.3.4">Differences from Double-Ratchet-based Protocols</a></li>
<li>1.3.5.   <a href="#rfc.section.1.3.5">Differences from Noise</a></li>
<li>1.3.6.   <a href="#rfc.section.1.3.6">Differences from MinimaLT</a></li>
</ul></ul><li>2.   <a href="#rfc.section.2">Protocol Overview</a></li>
<li>3.   <a href="#rfc.section.3">Handshake Protocols</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Features Common to All Handshakes</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">ClientInit Message</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">ServerInitAndAttest</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Identity Provisioning Protocol</a></li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">ClientIdentity_ClientAttest</a></li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Session Establishment Protocol</a></li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Session_ClientAttest</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Record Protocol</a></li>
<li>5.   <a href="#rfc.section.5">Error Handling</a></li>
<li>6.   <a href="#rfc.section.6">Cryptographic Computations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Notation</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Handshake Contexts</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Key Calculation and Schedule</a></li>
<li>6.4.   <a href="#rfc.section.6.4">SessionID Generation</a></li>
<li>6.5.   <a href="#rfc.section.6.5">ECDHE Parameters</a></li>
<li>6.6.   <a href="#rfc.section.6.6">Signature Algorithms</a></li>
<li>6.7.   <a href="#rfc.section.6.7">Per-message Nonce Calculation</a></li>
</ul><li>7.   <a href="#rfc.references">References</a></li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>7.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">State Machine</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Identity Provisioning Handshake</a></li>
<ul><li>A.1.1.   <a href="#rfc.appendix.A.1.1">Client</a></li>
<li>A.1.2.   <a href="#rfc.appendix.A.1.2">Server</a></li>
</ul><li>A.2.   <a href="#rfc.appendix.A.2">Session Establishment Handshake</a></li>
<ul><li>A.2.1.   <a href="#rfc.appendix.A.2.1">Client</a></li>
<li>A.2.2.   <a href="#rfc.appendix.A.2.2">Server</a></li>
</ul></ul><li>Appendix B.   <a href="#rfc.appendix.B">Presentation Language</a></li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Miscellaneous</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Definition of Byte</a></li>
<li>B.3.   <a href="#rfc.appendix.B.3">Byte Arrays</a></li>
<li>B.4.   <a href="#rfc.appendix.B.4">Numeric Data</a></li>
<li>B.5.   <a href="#rfc.appendix.B.5">Enumerateds</a></li>
<li>B.6.   <a href="#rfc.appendix.B.6">Constructed Types</a></li>
<li>B.7.   <a href="#rfc.appendix.B.7">AEAD-Encrypted Constructed Types</a></li>
<li>B.8.   <a href="#rfc.appendix.B.8">Constants</a></li>
<li>B.9.   <a href="#rfc.appendix.B.9">Variants</a></li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Protocol Data Structures and Constant Values</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Common Message Header</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Handshakes</a></li>
<ul><li>C.2.1.   <a href="#rfc.appendix.C.2.1">DAA Types</a></li>
<li>C.2.2.   <a href="#rfc.appendix.C.2.2">Server Certificates</a></li>
</ul><li>C.3.   <a href="#rfc.appendix.C.3">Record Layer</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is a WIP draft and has not yet seen significant security analysis.</p>
<p id="rfc.section.1.p.2">The primary goal of the XTT protocol is to provide a secure communication channel between an Internet of Things (IoT) device in the field and a backend network or server. The nature of the IoT imposes several constraints different from traditional transport layer security:</p>
<p/>

<ul>
  <li>Identity Provisioning: IoT devices will be numerous and must be low-cost, so manual provisioning of preshared keys (PSKs) or client certificates will not scale. Instead, devices must be provisioned long-term cryptographic identities in the field on first use. XTT leverages the Direct Anonymous Attestation {DAA} capabilties of modern processors to enable this.</li>
  <li>IP Address Mobility: The last-mile Internet access can change frequently for IoT devices. Needing to reestablish the secure channel after every IP address change is bad for energy- and bandwidth-constrained devices.  XTT decouples the secure channel from the underlying TCP or UDP transport socket.</li>
  <li>DoS Resistance: The secure communication channel is established over the public Internet, so the protocol must be designed to help the server-side resist denial of service (DoS) attacks.</li>
</ul>
<p id="rfc.section.1.p.4">The protocol must also provide the following traditional security properties:</p>
<p/>

<ul>
  <li>Mutual Authentication: Both the client and server sides are always authenticated. Server authentication happens via ECDSA and client authentication happens via PSK or DAA.</li>
  <li>Integrity: Data sent over the channel cannot be modified by an attacker.</li>
  <li>Confidentiality: Data sent over the channel is visible only to the endpoints. This property is optional; encryption may be disabled if the channel is tunneling data that was already encrypted.</li>
</ul>
<p id="rfc.section.1.p.6">The protocol must resist an attacker with complete control of the network, as described in <a href="#RFC3552">[RFC3552]</a>.</p>
<p id="rfc.section.1.p.7">XTT consists of three primary components:</p>
<p/>

<ul>
  <li>An identity provisioning protocol (<a href="#identity-provisioning-protocol">Section 3.2</a>) that (TODO) (1 par.) describe this protocol</li>
  <li>A session establishment protocol (<a href="#session-establishment-protocol">Section 3.3</a>) that (TODO) (1 par.) describe this protocol</li>
  <li>A record protocol (<a href="#record-protocol">Section 4</a>) that (TODO) (1 par.) describe this protocol</li>
</ul>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h2>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p id="rfc.section.1.1.p.3">client: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.4">endpoint: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.5">handshake: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.6">identity: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.7">receiver: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.8">sender: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.9">server: (TODO) (1 sent.)</p>
<p id="rfc.section.1.1.p.10">session: (TODO) (1 sent.)</p>
<h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#use-cases" id="use-cases">Use Cases</a></h2>
<p id="rfc.section.1.2.p.1">(TODO)</p>
<h2 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#security-requirements-for-the-iot" id="security-requirements-for-the-iot">Security Requirements for the IoT</a></h2>
<p id="rfc.section.1.3.p.1">(TODO) How IoT security differs from old world. What are the unique requirements.</p>
<h3 id="rfc.section.1.3.1"><a href="#rfc.section.1.3.1">1.3.1.</a> <a href="#differences-from-dtls" id="differences-from-dtls">Differences from (D)TLS</a></h3>
<p/>

<ul>
  <li>Heavyweight (heavy use of bandwidth during handshake)</li>
  <li>Designed around one-way, not mutual, authentication</li>
  <li>Non-confidential communication of identities during handshake</li>
  <li>Security session tied to connectivity session <ul><li>Having to re-run handshake every time underlying connection/IP changes compounds bandwidth problem</li></ul></li>
</ul>
<p id="rfc.section.1.3.1.p.2">(TODO) (1 list) what (D)TLS doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.3.2"><a href="#rfc.section.1.3.2">1.3.2.</a> <a href="#differences-from-quic" id="differences-from-quic">Differences from QUIC</a></h3>
<p/>

<ul>
  <li>Security session tied to connectivity session</li>
  <li>Not designed for mutual authentication</li>
</ul>
<p id="rfc.section.1.3.2.p.2">(TODO) (1 list) what QUIC doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.3.3"><a href="#rfc.section.1.3.3">1.3.3.</a> <a href="#differences-from-ikeipsec" id="differences-from-ikeipsec">Differences from IKE/IPSec</a></h3>
<p/>

<ul>
  <li>Pushing data requires performing full Two-Round-Trip handshake first</li>
  <li>Protects identity of server, not client, which is the opposite of what&#8217;s needed in IoT</li>
  <li>Very complex to configure, and easy to get wrong</li>
</ul>
<p id="rfc.section.1.3.3.p.2">(TODO) (1 list) what IKE doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.3.4"><a href="#rfc.section.1.3.4">1.3.4.</a> <a href="#differences-from-double-ratchet-based-protocols" id="differences-from-double-ratchet-based-protocols">Differences from Double-Ratchet-based Protocols</a></h3>
<p/>

<ul>
  <li>Per-message key updating is too heavy for most IoT, which doesn&#8217;t require per-message forward secrecy</li>
  <li>Doesn&#8217;t address identification (uses trust on first use)</li>
</ul>
<p id="rfc.section.1.3.4.p.2">(TODO) (1 list) what Double-Ratchet doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.3.5"><a href="#rfc.section.1.3.5">1.3.5.</a> <a href="#differences-from-noise" id="differences-from-noise">Differences from Noise</a></h3>
<p/>

<ul>
  <li>Designed mainly for either pre-shared (or statically-known) keys, or for unauthenticated communication</li>
</ul>
<p id="rfc.section.1.3.5.p.2">(TODO) (1 list) what Noise doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.3.6"><a href="#rfc.section.1.3.6">1.3.6.</a> <a href="#differences-from-minimalt" id="differences-from-minimalt">Differences from MinimaLT</a></h3>
<p/>

<ul>
  <li>Requires a highly-available directory service for name-lookup (unnecessary in IoT)</li>
  <li>Reliable-transport only (can cause issues on lossy networks commonly encountered in IoT)</li>
  <li>User-level authentication is inappropriate for IoT (devices aren&#8217;t multi-user)</li>
</ul>
<p id="rfc.section.1.3.6.p.2">(TODO) (1 list) what MinimalLT doesn&#8217;t offer that IoT requires</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.2.p.1">An XTT session is started using one of two related but distinct handshake protocols: one to create an Authenticated Session, and another to both create an Authenticated Session and provision a ClientID to the client.  Running an Authenticated Session handshake requires that a ClientID handshake has successfully been performed at least once previously.</p>
<p id="rfc.section.2.p.2">The ClientID handshake is used to authenticate both parties as being members of recognized and permissioned groups.  The typical case is of a client proving membership in a group permissioned to access a private network, and a server proving membership in the group of access points for that network.  Upon successful completion of a ClientID handshake, the server provisions to the client a ClientID, a unique identifier within the client&#8217;s group.  In addition, the client and server have now negotiated shared secret material that can be used for future authentication, without requiring the public-cryptography-based authentication of the ClientID handshake.</p>
<p id="rfc.section.2.p.3">Note that the lifetime of a given ClientID, i.e. the time between successive ClientID handshakes, is up to the discretion of the client.  It is possible for a given physical endpoint to perform a ClientID handshake only once (due to, for example, hardware constraints the preclude the required signatures) and retain the same ClientID for its entire lifetime.  Conversely, a client that does not wish its messages to be linkable by passive attackers may perform a ClientID handshake as often as every message; in fact, by using anonymized signature algorithms (e.g. Direct Anonymous Attestation), a client may keep active attackers and even the server from being able to link its messages to one another.</p>
<p id="rfc.section.2.p.4">The XTT AuthenticatedSession handshake can be performed after (or at the same time as) a successful ClientID handshake.  The AuthenticatedSession handshake leverages existing secret material shared between the client and server to generate shared secret cryptographic keys, to be used for encrypting and authenticating subsequent messages.</p>
<p id="rfc.section.2.p.5">Both XTT handshake protocols are based on the SigMA family of authenticated key exchange protocols, which is also the basis for signature-based authentication in the Internet Key Exchange version 2 (IKEv2) protocol <a href="#RFC7296">[RFC7296]</a> used in the IPSec protocol suite.  Specifically, the XTT protocol uses the SigMA-I variant described in <a href="#SIGMA">[SIGMA]</a>.  In particular, note that the present protocol does not place the MAC under the signature, as is done in IKEv2 (this is referred to as variant (ii) in <a href="#SIGMA">[SIGMA]</a>).  A formal security analysis of the SigMA protocols can be found in <a href="#SIGMASEC">[SIGMASEC]</a>.</p>
<p id="rfc.section.2.p.6">The handshake protocols are authenticated Diffie-Hellman key exchanges.  Both protocols require three messages, and only one full round-trip (1 RTT) before a client can begin pushing traffic.  The client, who is always the initiator of a handshake, may choose to begin pushing traffic with the third message, before receiving the final response from the server.  The reason for requiring 1 RTT (in distinction to the 0-RTT option proposed for the upcoming TLSv1.3 standard) is to protect against replay attacks.  The handshake protocol protects the confidentiality of the client&#8217;s identity from both passive and active attackers, while protecting the server&#8217;s identity from passive attackers (this isn&#8217;t an issue in IoT, as the server&#8217;s identity is usually known).</p>
<p id="rfc.section.2.p.7">(TODO) Specific handshake design aspects * Small, fixed-size messages during handshake * No arbitrary-length certificate chains</p>
<div id="rfc.figure.1"/>
<div id="xtt-provisioning"/>
<pre>
        Client                                             Server
        -----------------------             -----------------------
  
         CLIENTINIT
         + version
         + crypto-spec
         + session_id_seed_c
         + signing nonce
         + ECDHE public key      -------&gt;
                                           
                                             SERVERINITANDATTEST ^ &lt; Hk
                                                       version + | 
                                                   crypto-spec + | 
                                             session_id_seed_c + |
                                              ECDHE public key + | 
                                                 {certificate} + | 
                                           {session_id_seed_s} + | 
                                                   {signature} + |
                                 &lt;-------      {server cookie} + v 

  Hk &gt; ^ CLIENTATTEST 
       | + {DAA group key}
       | + ({identity request})
       v + {DAA signature}
  Sk &gt; ^
       | + ([Application Data])  -------&gt;
       v

                                                                 ^ &lt; Sk
                                                (SERVERFINISHED) |
                                 &lt;------- ([identity confirm]) + |
                                                                 v
  
  Sk &gt; ^                                                         ^ &lt; Sk
       |  RECORDREGULAR                            RECORDREGULAR |
       |  + [Application Data]   &lt;------&gt;   [Application Data] + |
       v                                                         v
  
              +  Indicates message subfields

              () Indicates optional messages/subfields

              {} Indicates data encrypted using handshake keys
  
              [] Indicates data encrypted using session keys
  
         Hk &gt; ^ 
              | Indicates data MAC'd using handshake keys
              v  
  
         Sk &gt; ^ 
              | Indicates data MAC'd using session keys
              v  
</pre>
<p class="figure">Figure 1: Message flow for XTT Identity Provisioning Handshake</p>
<div id="rfc.figure.2"/>
<div id="xtt-session"/>
<pre>
      Client                                                Server
     ^ ClientInit
     | + version and crypto-spec
     | + ECDHE public key
     v + session id seed          -------&gt; 
                                            
                                              ServerInitAndAttest ^    
                                        version and crypto-spec + |
                                               ECDHE public key + |     
                                                  {certificate} + |     
                                              {session id seed} + |     
                                                    {signature} + v
                                  &lt;-------
     ^  ClientAttest 
     | + {identity}
     | + {psk signature}
     v * [Application Data]       -------&gt;
                                  &lt;------        ServerFinished *

       [Application Data]         &lt;------&gt;     [Application Data]

            +  Indicates message subfields
              
            *  Indicates optional subfields/messages
              
            {} Indicates messages protected using
               handshake keys
               
            [] Indicates messages protected using
               session keys
</pre>
<p class="figure">Figure 2: Message flow for XTT Session Creation Handshake</p>
<p id="rfc.section.2.p.8">(TODO) record layer</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#handshake-protocols" id="handshake-protocols">Handshake Protocols</a></h1>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#features-common-to-all-handshakes" id="features-common-to-all-handshakes">Features Common to All Handshakes</a></h2>
<p id="rfc.section.3.1.p.1">The first two messages of a handshake (ClientInit and ServerInitAndAttest) are the same for both handshake types (ClientID and AuthenticatedSession).  When responding to a ClientInit with a ServerInitAndAttest, an implementation MAY store all necessary state in the ServerCookie embedded in the ServerInitAndAttest and save no state locally.</p>
<p id="rfc.section.3.1.p.2">After receiving a ServerInitAndAttest, a client responds with a ClientAttest message.  There are four variants of ClientAttest message, where two are for a ClientID handshake and two are for an AuthenticatedSession handshake.  For each handshake type, the two variants indicate whether or not a payload is included with the message.</p>
<h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#clientinit-message" id="clientinit-message">ClientInit Message</a></h3>
<p id="rfc.section.3.1.1.p.1">All handshakes begin with the client sending a ClientInit message to the server.  A client may resend a ClientInit if it has not received a ServerInitAndAttest in response within a timeout period.  There is no requirement that ClientInit retries be identical, as long as a client only responds to one ServerInitAndAttest response.</p>
<p id="rfc.section.3.1.1.p.2">Structure of this message:</p>
<pre>
struct {
    MsgType type = client_init;
    Version version;
    SuiteSpec spec;
    SessionIDSeed session_id_seed;
    SigningNonce client_nonce;
    DHKeyShare client_dh_keyshare;
} ClientInit;
</pre>
<h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#serverinitandattest" id="serverinitandattest">ServerInitAndAttest</a></h3>
<p id="rfc.section.3.1.2.p.1">Structure of this message:</p>
<pre>
aead_struct&lt;handshake_keys&gt;(
    MsgType type = server_init_and_attest;
    Version version;
    SuiteSpec spec;
    SessionIDSeed session_id_seed;   /* echo from client */
    DHKeyShare server_dh_keyshare;
)[
    ServerCertificate certificate;
    SessionIDSeed session_id_seed;
    ServerSignature server_signature;
    ServerCookie server_cookie;
] ServerInitAndAttest;
</pre>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#identity-provisioning-protocol" id="identity-provisioning-protocol">Identity Provisioning Protocol</a></h2>
<p id="rfc.section.3.2.p.1">This handshake provisions a ClientID to a client and simultaneously creates an AuthenticatedSession.</p>
<h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#clientidentityclientattest" id="clientidentityclientattest">ClientIdentity_ClientAttest</a></h3>
<pre>
aead_struct&lt;handshake_keys&gt;(
    MsgType type =  MsgType.id_clientattest_nopayload;
    Version version;
    SuiteSpec spec;
    byte flags[1];
    ServerCookie server_cookie;     /* echo from server */
}[
    DAAGroupKey daa_gpk;
    ClientID id;
    DAASignature signature;
] ClientIdentity_ClientAttest_NoPayload;
</pre>
<pre>
struct {
    aead_struct&lt;handshake_keys&gt;(
        MsgType type = MsgType.id_clientattest_payload;
        Version version;
        SuiteSpec spec;
        byte flags[1];
        ServerCookie server_cookie;     /* echo from server */
    }[
        DAAGroupKey daa_gpk;
        ClientID id;
        DAASignature signature;
    ];
    aead_struct&lt;session_keys&gt;(
        MsgLength length;               /* total length */
    )[
        EncapsulatedPayloadType payload_type;
        byte payload[length - sizeof(rest_of_message)];
    ];
} ClientIdentity_ClientAttest_Payload;
</pre>
<pre>
aead_struct&lt;session_keys&gt;(
    MsgType type = MsgType.id_serverfinished;
    Version version;
    SuiteSpec spec;
)[
    ClientID client_id;     /* confirm id of client */
    FinishedContext ctx;
] ClientIdentity_ServerFinished;
</pre>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#session-establishment-protocol" id="session-establishment-protocol">Session Establishment Protocol</a></h2>
<h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#sessionclientattest" id="sessionclientattest">Session_ClientAttest</a></h3>
<pre>
aead_struct&lt;handshake_keys&gt;(
    MsgType type =  MsgType.session_clientattest_nopayload;
    Version version;
    SuiteSpec spec;
    byte flags[1];
    ServerCookie server_cookie;     /* echo from server */
}[
    ClientID id;
    PSKSignature signature;
] AuthenticatedSession_ClientAttest_NoPayload;
</pre>
<pre>
struct {
    aead_struct&lt;handshake_keys&gt;(
        MsgType type = MsgType.session_clientattest_payload;
        Version version;
        SuiteSpec spec;
        byte flags[1];
        ServerCookie server_cookie;     /* echo from server */
    }[
        ClientID id;
        PSKSignature signature;
    ];
    aead_struct&lt;session_keys&gt;(
        MsgLength length;               /* total length */
    )[
        EncapsulatedPayloadType payload_type;
        byte payload[length - sizeof(rest_of_message)];
    ];
} AuthenticatedSession_ClientAttest_Payload;
</pre>
<pre>
aead_struct&lt;session_keys&gt;(
    MsgType type = MsgType.session_serverfinished;
    Version version;
    SuiteSpec spec;
)[
    FinishedContext ctx;
] AuthenticatedSession_ServerFinished;
</pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#record-protocol" id="record-protocol">Record Protocol</a></h1>
<pre>
aead_struct&lt;session_keys&gt;(
    MsgType type = MsgType.record_regular;
    Version version;
    SessionID session_id;
    SequenceNumber seq_num;
    MsgLength length;
)[
    EncapsulatedPayloadType payload_type;
    byte payload[length - sizeof(rest_of_message)];
] Record_Regular;
</pre>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#error-handling" id="error-handling">Error Handling</a></h1>
<p id="rfc.section.5.p.1">(TODO)</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#cryptographic-computations" id="cryptographic-computations">Cryptographic Computations</a></h1>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#notation" id="notation">Notation</a></h2>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#handshake-contexts" id="handshake-contexts">Handshake Contexts</a></h2>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#key-calculation-and-schedule" id="key-calculation-and-schedule">Key Calculation and Schedule</a></h2>
<h2 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#sessionid-generation" id="sessionid-generation">SessionID Generation</a></h2>
<h2 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#ecdhe-parameters" id="ecdhe-parameters">ECDHE Parameters</a></h2>
<p id="rfc.section.6.5.p.1">The size and interpretation of a value of type DHKeyShare depends on the Diffie-Hellman algorithm specified in the handshake messages.</p>
<p id="rfc.section.6.5.p.2">Currently, only x25519 is supported by the protocol.</p>
<p id="rfc.section.6.5.p.3">For x25519, the contents are the byte string inputs and outputs of the corresponding functions defined in <a href="#RFC7748">[RFC7748]</a>.  The size of the DHKeyShare in this case is 32 bytes.</p>
<h2 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#signature-algorithms" id="signature-algorithms">Signature Algorithms</a></h2>
<h2 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a> <a href="#per-message-nonce-calculation" id="per-message-nonce-calculation">Per-message Nonce Calculation</a></h2>
<p id="rfc.section.6.7.p.1">(TODO)</p>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">7.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5869">[RFC5869]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7539">[RFC7539]</b>
      </td>
      <td class="top"><a>Nir, Y.</a> and <a>A. Langley</a>, "<a href="http://tools.ietf.org/html/rfc7539">ChaCha20 and Poly1305 for IETF Protocols</a>", RFC 7539, DOI 10.17487/RFC7539, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7693">[RFC7693]</b>
      </td>
      <td class="top"><a>Saarinen, M-J.</a> and <a>J-P. Aumasson</a>, "<a href="http://tools.ietf.org/html/rfc7693">The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)</a>", RFC 7693, DOI 10.17487/RFC7693, November 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7748">[RFC7748]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="http://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SHS">[SHS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology</a>, "<a>Secure Hash Standard</a>", NIST FIPS PUB 180-4, March 2012.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">7.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="MINIMALT">[MINIMALT]</b>
      </td>
      <td class="top"><a>Petullo, W.</a>, <a>Zhang, X.</a>, <a>Solworth, J.</a>, <a>Bernstein, D.</a> and <a>T. Lange</a>, "<a>MinimalLT: Minimal-latency Networking Through Better Security</a>", November 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7296">[RFC7296]</b>
      </td>
      <td class="top"><a>Kaufman, C.</a>, <a>Hoffman, P.</a>, <a>Nir, Y.</a>, <a>Eronen, P.</a> and <a>T. Kivinen</a>, "<a href="http://tools.ietf.org/html/rfc7296">Internet Key Exchange Protocol Version 2 (IKEv2)</a>", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SIGMA">[SIGMA]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, "<a>SIGMA: the 'SIGn-and-MAc' approach to authenticated Diffie-Hellman and its use in the IKE protocols</a>", Proceedings of CRYPTO 2003 , June 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SIGMASEC">[SIGMASEC]</b>
      </td>
      <td class="top"><a>Canetti, R.</a> and <a>H. Krawczyk</a>, "<a>Security Analysis of IKE's Signature-Based Key-Exchange Protocol</a>", October 2002.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#state-machine" id="state-machine">State Machine</a></h1>
<p id="rfc.section.A.p.1">This section provides a summary of the legal state machine transitions for the client and server handshakes.  State names (in all capitals, e.g., START) have no formal meaning, but are provided for ease of comprehension. Messages which are sent only sometimes are indicated in <samp>[]</samp>.  (TODO)</p>
<h2 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> <a href="#identity-provisioning-handshake" id="identity-provisioning-handshake">Identity Provisioning Handshake</a></h2>
<h3 id="rfc.appendix.A.1.1"><a href="#rfc.appendix.A.1.1">A.1.1.</a> <a href="#client" id="client">Client</a></h3>
<p id="rfc.section.A.1.1.p.1">(TODO)</p>
<h3 id="rfc.appendix.A.1.2"><a href="#rfc.appendix.A.1.2">A.1.2.</a> <a href="#server" id="server">Server</a></h3>
<p id="rfc.section.A.1.2.p.1">(TODO)</p>
<h2 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> <a href="#session-establishment-handshake" id="session-establishment-handshake">Session Establishment Handshake</a></h2>
<h3 id="rfc.appendix.A.2.1"><a href="#rfc.appendix.A.2.1">A.2.1.</a> <a href="#client-1" id="client-1">Client</a></h3>
<p id="rfc.section.A.2.1.p.1">(TODO)</p>
<h3 id="rfc.appendix.A.2.2"><a href="#rfc.appendix.A.2.2">A.2.2.</a> <a href="#server-1" id="server-1">Server</a></h3>
<p id="rfc.section.A.2.2.p.1">(TODO)</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#presentation-language" id="presentation-language">Presentation Language</a></h1>
<h2 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> <a href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h2>
<p id="rfc.section.B.1.p.1">Comments begin with &#8220;/*&#8221; and end with &#8220;*/&#8221;.</p>
<p id="rfc.section.B.1.p.2">To indicate the number of bytes taken up in the byte stream by a type or value, the expression <samp>sizeof(value-or-type)</samp> is used.</p>
<p id="rfc.section.B.1.p.3">Optional components are denoted by enclosing them in <samp>[[ ]]</samp> double brackets.</p>
<h2 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> <a href="#definition-of-byte" id="definition-of-byte">Definition of Byte</a></h2>
<p id="rfc.section.B.2.p.1">One byte is defined to be 8 bits.  Multiple-byte data items are concatenations of bytes, from left to right, from top to bottom.</p>
<h2 id="rfc.appendix.B.3"><a href="#rfc.appendix.B.3">B.3.</a> <a href="#byte-arrays" id="byte-arrays">Byte Arrays</a></h2>
<p id="rfc.section.B.3.p.1">A byte-array is a single-dimensional array of bytes of given fixed length.  The syntax for specifying a new type, <samp>Tp</samp>, that is a byte-array of length <samp>n</samp> is</p>
<pre>
byte Tp[n];
</pre>
<p id="rfc.section.B.3.p.2">Here, <samp>Tp</samp> occupies <samp>n</samp> bytes in the data stream.  The length of the vector is not included in the encoded stream.</p>
<p id="rfc.section.B.3.p.3">An anonymous byte array is specified by not including a new type name: <samp>byte[n]</samp> indicates space of n bytes in the byte stream.  This is useful for constructed and variant types.</p>
<p id="rfc.section.B.3.p.4">Unless defined as a numeric data type, the bytes comprising a byte-array are not to be interpreted by the protocol in any way.</p>
<h2 id="rfc.appendix.B.4"><a href="#rfc.appendix.B.4">B.4.</a> <a href="#numeric-data" id="numeric-data">Numeric Data</a></h2>
<p id="rfc.section.B.4.p.1">A type defined as an n-byte numeric value indicates that the byte stream is interpreted (using C notation) as:</p>
<pre>
numeric_value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
        ... | byte[n-1];
</pre>
<p id="rfc.section.B.4.p.2">This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.  The pre-defined numeric types uint8, uint16, uint32, and uint64 are defined as</p>
<pre>
byte uint8[1];
byte uint16[2];
byte uint32[4];
byte uint64[8];
</pre>
<p id="rfc.section.B.4.p.3">For example, the uint32 value given by the bytestream <samp>01 02 03 04</samp> is interpreted as the decimal value 16909060.</p>
<h2 id="rfc.appendix.B.5"><a href="#rfc.appendix.B.5">B.5.</a> <a href="#enumerateds" id="enumerateds">Enumerateds</a></h2>
<p id="rfc.section.B.5.p.1">To indicate a type that may take values only from a fixed set of possible values, a new type may be defined as of type <samp>enum</samp>.  Each definition of an enumerated type is a different type.  Only enumerateds of the same type may be assigned or compared.  Every element of an enumerated must be assigned a value.</p>
<p id="rfc.section.B.5.p.2">The possible values of an enumerated type are specified in this document using numeric values.  To indicate how to interpret a value of an enumerated type, and to indicate how much space in the byte stream is occupied by an enumerated type, the definition of the enumerated type includes the underlying numeric type used to define its values.</p>
<p id="rfc.section.B.5.p.3">Implementations that receive a value of an enumerated type that is not in the set of possible values for that type MUST reject the containing message and handle the error as specified for that message type.</p>
<p id="rfc.section.B.5.p.4">The following example defines an enumerated type called Color that has three possible values, which are represented in the byte stream as uint16 values (thus a value of type Color occupies 2 bytes in the byte stream)</p>
<pre>
enum : uint16 {
    Red(0x1234),
    Green(9),
    Blue(60000)
} Color;
</pre>
<p id="rfc.section.B.5.p.5">The names of the elements of an enumerated type are scoped within the defined type, and a reference in this document to the value of a name is always given by the fully-qualified form <samp>Type.Name</samp>.  Thus a reference to the <samp>Color</samp> value <samp>Blue</samp> from above is given by <samp>Color.Blue</samp>.</p>
<h2 id="rfc.appendix.B.6"><a href="#rfc.appendix.B.6">B.6.</a> <a href="#constructed-types" id="constructed-types">Constructed Types</a></h2>
<p id="rfc.section.B.6.p.1">Complex types may be constructed from primitive types, using the <samp>struct</samp> construction.  Each constructed type defines a new type.</p>
<p id="rfc.section.B.6.p.2">The following example defines a constructed type called <samp>T</samp>, which comprises two subfields <samp>f1</samp> and <samp>f2</samp></p>
<pre>
struct {
    T1 f1;
    T2 f2;
} T;
</pre>
<p id="rfc.section.B.6.p.3">A value of type <samp>T</samp> would occupy a total of <samp>sizeof(T1) + sizeof(T2)</samp> bytes in the byte stream.</p>
<p id="rfc.section.B.6.p.4">Subfields of a constructed type are referenced in this document by <samp>Type.subfield</samp> when referring to the field in the general type <samp>Type</samp>, and by <samp>name.subfield</samp> when referring to the field in a specific value named <samp>name</samp>.  Thus, the value of the subfield <samp>f2</samp> in a value called <samp>foo</samp> of type <samp>T</samp>, from the example above, would be referenced as <samp>foo.f1</samp>.</p>
<h2 id="rfc.appendix.B.7"><a href="#rfc.appendix.B.7">B.7.</a> <a href="#aead-encrypted-constructed-types" id="aead-encrypted-constructed-types">AEAD-Encrypted Constructed Types</a></h2>
<p id="rfc.section.B.7.p.1">Encryption and authentication of all messages in this protocol are done using Authenticated Encryption with Additional Data (AEAD) <a href="#RFC5116">[RFC5116]</a>.  To indicate that a constructed type is processed using an AEAD algorithm, the following notation is used:</p>
<pre>
aead_struct&lt;key_set&gt;(
    addl1;
    addl2;
    ...
    addlN;
)[
    enc1;
    enc2;
    ...
    encN;
] T;
</pre>
<p id="rfc.section.B.7.p.2">In this example, the type <samp>T</samp> consists of the unencrypted subfields <samp>addl1</samp> through <samp>addlN</samp>, and the encrypted subfields <samp>enc1</samp> through <samp>encN</samp>.  The keys (encryption key, authentication key, and nonce) used is given by <samp>key_set</samp>.  The entire struct is authenticated.  Note that the total length in the byte stream of a value of type <samp>T</samp> is the size of an authentication tag (determined by the chosen AEAD algorithm) in addition to the sum of the sizes of its subfields.</p>
<h2 id="rfc.appendix.B.8"><a href="#rfc.appendix.B.8">B.8.</a> <a href="#constants" id="constants">Constants</a></h2>
<p id="rfc.section.B.8.p.1">Fields and variables may be assigned a fixed value using <samp>=</samp>.  In the following example, all values of type <samp>T</samp> would always have <samp>T.c</samp> equal to <samp>Color.Blue</samp></p>
<pre>
struct {
    Color c = Color.Blue;
    T2 f2;
} T;
</pre>
<h2 id="rfc.appendix.B.9"><a href="#rfc.appendix.B.9">B.9.</a> <a href="#variants" id="variants">Variants</a></h2>
<p id="rfc.section.B.9.p.1">Defined structures may have variants based on some knowledge that is available within the environment.  The selector must be an enumerated type that defines the possible variants the structure defines.  There must be a case arm for every element of the enumeration declared in the select.  Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields.</p>
<p id="rfc.section.B.9.p.2">The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.</p>
<p id="rfc.section.B.9.p.3">For example:</p>
<pre>
uint8 SubT1;
uint16 SubT2;
struct {
    select (color_in) {
        case Color.Red:
            SubT1;
        case Color.Green:
        case Color.Blue:
            SubT2;
    } variant_field;
} VariantStruct;
</pre>
<p id="rfc.section.B.9.p.4">In this example, it is assumed the creation of a value of type <samp>VariantStruct</samp> requires the input of a parameter called <samp>color_in</samp> of type <samp>Color</samp>.  When creating a value of type VariantStruct with name S, if <samp>color_in</samp> is <samp>Red</samp> then the subfield <samp>S.variant_field</samp> is of type <samp>SubT1</samp>.  Alternatively, if <samp>color_in</samp> is either <samp>Green</samp> or <samp>Blue</samp>, <samp>S.variant_field</samp> is of type <samp>SubT2</samp>.  Note that the size of the type <samp>VariantStruct</samp> depends on the value of <samp>color_in</samp> at the time of construction.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#protocol-data-structures-and-constant-values" id="protocol-data-structures-and-constant-values">Protocol Data Structures and Constant Values</a></h1>
<p id="rfc.section.C.p.1">This section describes protocol types and constants.</p>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#common-message-header" id="common-message-header">Common Message Header</a></h2>
<pre>
enum : uint8 {
    client_init(0x01),
    server_init_and_attest(0x02),
    id_clientattest_response_nopayload_ip(0x11),
    id_clientattest_response_payload_ip(0x12),
    id_clientattest_response_nopayload_noip(0x13),
    id_clientattest_response_payload_noip(0x14),
    id_clientattest_noresponse_payload_ip(0x15),
    id_clientattest_noresponse_payload_noip(0x16),
    id_serverfinished(0x17),
    session_clientattest_response_nopayload_ip(0x21),
    session_clientattest_response_payload_ip(0x22),
    session_clientattest_response_nopayload_noip(0x23),
    session_clientattest_response_payload_noip(0x24),
    session_clientattest_noresponse_payload_ip(0x25),
    session_clientattest_noresponse_payload_noip(0x26),
    session_serverfinished(0x27),
    record_regular(0x31),
    alert(0x41)
} MsgType;
</pre>
<pre>
enum : uint8 {
    one(1)
} Version;
</pre>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#handshakes" id="handshakes">Handshakes</a></h2>
<pre>
enum : uint16 {
    x25519_epid2_chacha20poly1305_sha512(1),
    x25519_epid2_chacha20poly1305_blake2b(2),
    x25519_epid2_aes256gcm_sha512(3),
    x25519_epid2_aes256gcm_blake2b(4),
    x25519_epid2_null_sha512(5),
    x25519_epid2_null_blake2b(6)
} SuiteSpec;
</pre>
<pre>
byte SessionIDSeed[8];
</pre>
<pre>
byte SigningNonce[32];
</pre>
<pre>
byte ServerCookie[130];
</pre>
<pre>
byte ClientID[16];
</pre>
<pre>
byte LongtermSecret[64];
</pre>
<pre>
select(dh_algorithm) {
    byte[&lt;size of public key for this algorithm&gt;];
} DHKeyShare;
</pre>
<pre>
enum : uint8 {
    Ed25519(1)
} ServerSignatureType;
</pre>
<pre>
select(server_signature_algorithm) {
    byte[&lt;size of signature for this algorithm&gt;];
} ServerSignature;
</pre>
<pre>
select(server_signature_algorithm) {
    byte[&lt;size of public key for this algorithm&gt;];
} ServerSignaturePublicKey;
</pre>
<h3 id="rfc.appendix.C.2.1"><a href="#rfc.appendix.C.2.1">C.2.1.</a> <a href="#daa-types" id="daa-types">DAA Types</a></h3>
<pre>
select(dh_algorithm) {
    byte[&lt;size of group public key for this algorithm&gt;];
} DAAGroupKey;
</pre>
<pre>
select(dh_algorithm) {
    byte[&lt;size of signature for this algorithm&gt;];
} DAASignature;
</pre>
<h3 id="rfc.appendix.C.2.2"><a href="#rfc.appendix.C.2.2">C.2.2.</a> <a href="#server-certificates" id="server-certificates">Server Certificates</a></h3>
<pre>
enum : uint8 {
    one(1)
} ServerCertificateVersion;
</pre>
<pre>
byte Date[8];   /* YYYYMMDD according to UTC */
</pre>
<pre>
struct {
    ServerCertificateVersion version;
    ServerSignatureType algorithm;
    Date expiry;
    ClientID id;
    ServerSignature signature;
    ServerIntermediateCertificate signers_certificate;
    ServerSignature signers_signature;
} ServerCertificate;
</pre>
<pre>
struct {
    ServerSignatureVersion version;
    ServerSignatureType algorithm;
    Date expiry;
    ServerSignaturePublicKey public_key;
    byte root_id[32];       /* ServerRootCertificate to use */
    ServerSignature root_signature;
} ServerIntermediateCertificate;
</pre>
<pre>
struct {
    ServerSignatureVersion version;
    ServerSignatureType algorithm;
    Date expiry;
    ServerSignaturePublicKey public_key;
    byte id[32];
} ServerRootCertificate;
</pre>
<h2 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> <a href="#record-layer" id="record-layer">Record Layer</a></h2>
<pre>
byte SessionID[16];
</pre>
<pre>
uint32 SequenceNumber;
</pre>
<pre>
uint16 MsgLength;
</pre>
<pre>
enum : uint8 {
    queue_protocol(1),
    ipv6(2)
} EncapsulatedPayloadType;
</pre>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Zane Beckwith</span> 
	  <span class="n hidden">
		<span class="family-name">Beckwith</span>
	  </span>
	</span>
	<span class="org vcardline">Xaptum, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:zane.beckwith@xaptum.com">zane.beckwith@xaptum.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David R. Bild</span> 
	  <span class="n hidden">
		<span class="family-name">Bild</span>
	  </span>
	</span>
	<span class="org vcardline">Xaptum, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:david.bild@xaptum.com">david.bild@xaptum.com</a></span>

  </address>
</div>

</body>
</html>
