<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Xaptum Trusted Transit (XTT) Protocol Version 1.0</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Use Cases"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Design Goals"/>
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Security Requirements for the IoT"/>
<link href="#rfc.section.1.4.1" rel="Chapter" title="1.4.1 Differences from (D)TLS"/>
<link href="#rfc.section.1.4.2" rel="Chapter" title="1.4.2 Differences from QUIC"/>
<link href="#rfc.section.1.4.3" rel="Chapter" title="1.4.3 Differences from IKE/IPSec"/>
<link href="#rfc.section.1.4.4" rel="Chapter" title="1.4.4 Differences from Double-Ratchet-based Protocols"/>
<link href="#rfc.section.1.4.5" rel="Chapter" title="1.4.5 Differences from Noise"/>
<link href="#rfc.section.1.4.6" rel="Chapter" title="1.4.6 Differences from MinimaLT"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Handshake Protocols"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Common Messages"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 ClientInit"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 ServerInitAndAttest"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Identity Provisioning Protocol"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 ClientIdentity_ClientAttest"/>
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 ClientIdentity_ServerFinished"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Session Establishment Protocol"/>
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Session_ClientAttest"/>
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Session_ServerFinished"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Behaviors Common to Both Handshake Protocols"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Record Protocol"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Error Handling"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Cryptographic Computations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Notation"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Transcript Hashes"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Key Calculation and Schedule"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 ECDHE Parameters"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 DAA Parameters"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Signature Algorithms"/>
<link href="#rfc.section.6.6.1" rel="Chapter" title="6.6.1 ServerSignature"/>
<link href="#rfc.section.6.6.2" rel="Chapter" title="6.6.2 SymmetricSignature"/>
<link href="#rfc.section.6.6.3" rel="Chapter" title="6.6.3 DAASignature"/>
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Per-message Nonce Calculation"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A State Machine"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Identity Provisioning Handshake"/>
<link href="#rfc.appendix.A.1.1" rel="Chapter" title="A.1.1 Client"/>
<link href="#rfc.appendix.A.1.2" rel="Chapter" title="A.1.2 Server"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Session Establishment Handshake"/>
<link href="#rfc.appendix.A.2.1" rel="Chapter" title="A.2.1 Client"/>
<link href="#rfc.appendix.A.2.2" rel="Chapter" title="A.2.2 Server"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Presentation Language"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Miscellaneous"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Definition of Byte"/>
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Byte Arrays"/>
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Numeric Data"/>
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Enumerateds"/>
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Constructed Types"/>
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 AEAD-Encrypted Constructed Types"/>
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Constants"/>
<link href="#rfc.appendix.B.9" rel="Chapter" title="B.9 Variants"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Protocol Data Structures and Constant Values"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Common Message Header"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Handshakes"/>
<link href="#rfc.appendix.C.2.1" rel="Chapter" title="C.2.1 Signature Types"/>
<link href="#rfc.appendix.C.2.2" rel="Chapter" title="C.2.2 Server Certificates"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Record Layer"/>
<link href="#rfc.appendix.D" rel="Chapter" title="D Implementation Notes"/>
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Distributed Servers and Proxies"/>
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Server Cookie and DoS Attacks"/>
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 Underlying Transport Protocol"/>
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 Cryptographic Requirements"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Beckwith, Z. and D. Bild" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-xaptum-xtt-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-5-23" />
  <meta name="dct.abstract" content="This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality." />
  <meta name="description" content="This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">Z. Beckwith</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">D. Bild</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">Xaptum, Inc.</td>
</tr>
<tr>
  <td class="left">Expires: November 24, 2017</td>
  <td class="right">May 23, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Xaptum Trusted Transit (XTT) Protocol Version 1.0<br />
  <span class="filename">draft-xaptum-xtt-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies version 1.0 of the Xaptum Trusted Transit (XTT) protocol for securing the Internet of Things (IoT). It provides scalable identitiy provisioning, device authentication, and data integrity and confidentiality.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 24, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may not be modified, and derivative works of it may not be created, and it may not be published except as an Internet-Draft.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Use Cases</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Design Goals</a></li>
<li>1.4.   <a href="#rfc.section.1.4">Security Requirements for the IoT</a></li>
<ul><li>1.4.1.   <a href="#rfc.section.1.4.1">Differences from (D)TLS</a></li>
<li>1.4.2.   <a href="#rfc.section.1.4.2">Differences from QUIC</a></li>
<li>1.4.3.   <a href="#rfc.section.1.4.3">Differences from IKE/IPSec</a></li>
<li>1.4.4.   <a href="#rfc.section.1.4.4">Differences from Double-Ratchet-based Protocols</a></li>
<li>1.4.5.   <a href="#rfc.section.1.4.5">Differences from Noise</a></li>
<li>1.4.6.   <a href="#rfc.section.1.4.6">Differences from MinimaLT</a></li>
</ul></ul><li>2.   <a href="#rfc.section.2">Protocol Overview</a></li>
<li>3.   <a href="#rfc.section.3">Handshake Protocols</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Common Messages</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">ClientInit</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">ServerInitAndAttest</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Identity Provisioning Protocol</a></li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">ClientIdentity_ClientAttest</a></li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">ClientIdentity_ServerFinished</a></li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Session Establishment Protocol</a></li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Session_ClientAttest</a></li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Session_ServerFinished</a></li>
</ul><li>3.4.   <a href="#rfc.section.3.4">Behaviors Common to Both Handshake Protocols</a></li>
</ul><li>4.   <a href="#rfc.section.4">Record Protocol</a></li>
<li>5.   <a href="#rfc.section.5">Error Handling</a></li>
<li>6.   <a href="#rfc.section.6">Cryptographic Computations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Notation</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Transcript Hashes</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Key Calculation and Schedule</a></li>
<li>6.4.   <a href="#rfc.section.6.4">ECDHE Parameters</a></li>
<li>6.5.   <a href="#rfc.section.6.5">DAA Parameters</a></li>
<li>6.6.   <a href="#rfc.section.6.6">Signature Algorithms</a></li>
<ul><li>6.6.1.   <a href="#rfc.section.6.6.1">ServerSignature</a></li>
<li>6.6.2.   <a href="#rfc.section.6.6.2">SymmetricSignature</a></li>
<li>6.6.3.   <a href="#rfc.section.6.6.3">DAASignature</a></li>
</ul><li>6.7.   <a href="#rfc.section.6.7">Per-message Nonce Calculation</a></li>
</ul><li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">State Machine</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Identity Provisioning Handshake</a></li>
<ul><li>A.1.1.   <a href="#rfc.appendix.A.1.1">Client</a></li>
<li>A.1.2.   <a href="#rfc.appendix.A.1.2">Server</a></li>
</ul><li>A.2.   <a href="#rfc.appendix.A.2">Session Establishment Handshake</a></li>
<ul><li>A.2.1.   <a href="#rfc.appendix.A.2.1">Client</a></li>
<li>A.2.2.   <a href="#rfc.appendix.A.2.2">Server</a></li>
</ul></ul><li>Appendix B.   <a href="#rfc.appendix.B">Presentation Language</a></li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Miscellaneous</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Definition of Byte</a></li>
<li>B.3.   <a href="#rfc.appendix.B.3">Byte Arrays</a></li>
<li>B.4.   <a href="#rfc.appendix.B.4">Numeric Data</a></li>
<li>B.5.   <a href="#rfc.appendix.B.5">Enumerateds</a></li>
<li>B.6.   <a href="#rfc.appendix.B.6">Constructed Types</a></li>
<li>B.7.   <a href="#rfc.appendix.B.7">AEAD-Encrypted Constructed Types</a></li>
<li>B.8.   <a href="#rfc.appendix.B.8">Constants</a></li>
<li>B.9.   <a href="#rfc.appendix.B.9">Variants</a></li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Protocol Data Structures and Constant Values</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Common Message Header</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Handshakes</a></li>
<ul><li>C.2.1.   <a href="#rfc.appendix.C.2.1">Signature Types</a></li>
<li>C.2.2.   <a href="#rfc.appendix.C.2.2">Server Certificates</a></li>
</ul><li>C.3.   <a href="#rfc.appendix.C.3">Record Layer</a></li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Implementation Notes</a></li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Distributed Servers and Proxies</a></li>
<li>D.2.   <a href="#rfc.appendix.D.2">Server Cookie and DoS Attacks</a></li>
<li>D.3.   <a href="#rfc.appendix.D.3">Underlying Transport Protocol</a></li>
<li>D.4.   <a href="#rfc.appendix.D.4">Cryptographic Requirements</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is a WIP draft and has not yet seen significant security analysis.</p>
<p id="rfc.section.1.p.2">The primary goal of the XTT protocol is to provide a secure communication channel between an Internet of Things (IoT) device in the field and a backend network or server. The nature of the IoT imposes several constraints that differ from traditional transport layer security:</p>
<p/>

<ul>
  <li>Identity Provisioning: IoT devices will be numerous and must be low-cost, so manual provisioning of preshared keys (PSKs) or client certificates will not scale. Instead, devices must be provisioned long-term cryptographic identities in the field on first use. XTT leverages the Direct Anonymous Attestation <a href="#DAA">[DAA]</a> capabilties of modern processors to enable this.</li>
  <li>IP Address Mobility: The last-mile Internet access can change frequently for IoT devices. Needing to reestablish the secure channel after every IP address change consumes precious energy and bandwidth.  XTT decouples the secure channel from the underlying TCP/IP or UDP/IP transport socket</li>
  <li>DoS Resistance: The secure communication channel is established over the public Internet, so the protocol must be designed to help the server-side resist denial of service (DoS) attacks.</li>
</ul>
<p id="rfc.section.1.p.4">The protocol must also provide the following traditional security properties:</p>
<p/>

<ul>
  <li>Mutual Authentication: Both the client and server sides are always authenticated. Server authentication happens via ECDSA and client authentication happens via symmetric-key-signature or DAA.</li>
  <li>Integrity: Data sent over the channel cannot be modified by an attacker.</li>
  <li>Confidentiality: Data sent over the channel is visible only to the endpoints. This property is optional; encryption may be disabled if the channel is tunneling data that was already encrypted.</li>
</ul>
<p id="rfc.section.1.p.6">The protocol must resist an attacker with complete control of the network, as described in <a href="#RFC3552">[RFC3552]</a>.</p>
<p id="rfc.section.1.p.7">XTT consists of three primary components:</p>
<p/>

<ul>
  <li>An identity provisioning protocol (<a href="#identity-provisioning-protocol">Section 3.2</a>) used by the device to request an identity from the server and establish a long-term shared secret.</li>
  <li>A session establishment protocol (<a href="#session-establishment-protocol">Section 3.3</a>) that (TODO) (1 par.) describe this protocol</li>
  <li>A record protocol (<a href="#record-protocol">Section 4</a>) that (TODO) (1 par.)  describe this protocol</li>
</ul>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h2>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p id="rfc.section.1.1.p.3">client: The initiator in a handshake.</p>
<p id="rfc.section.1.1.p.4">connection: A transport-layer connection between client and server, over which XTT traffic is sent.</p>
<p id="rfc.section.1.1.p.5">endpoint: The physical device that is acting as either client or server during communication.</p>
<p id="rfc.section.1.1.p.6">handshake: An initial negotiation between client and server for either provisioning authorization data to the client or establishing shared cryptographic information for subsequent communication.</p>
<p id="rfc.section.1.1.p.7">identity: A universally-unique tag used to identify a client to a server or to any other clients that may be peers.</p>
<p id="rfc.section.1.1.p.8">server: The responder in a handshake.</p>
<p id="rfc.section.1.1.p.9">session: A collection of cryptographic parameters and secrets used for secure communication.</p>
<h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#use-cases" id="use-cases">Use Cases</a></h2>
<p id="rfc.section.1.2.p.1">(TODO)</p>
<h2 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#design-goals" id="design-goals">Design Goals</a></h2>
<p id="rfc.section.1.3.p.1">(TODO)</p>
<p/>

<ul>
  <li>Small, fixed-size messages during handshake <ul><li>No arbitrary-length certificate chains</li></ul></li>
</ul>
<h2 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a> <a href="#security-requirements-for-the-iot" id="security-requirements-for-the-iot">Security Requirements for the IoT</a></h2>
<p id="rfc.section.1.4.p.1">(TODO) How IoT security differs from old world. What are the unique requirements.</p>
<h3 id="rfc.section.1.4.1"><a href="#rfc.section.1.4.1">1.4.1.</a> <a href="#differences-from-dtls" id="differences-from-dtls">Differences from (D)TLS</a></h3>
<p/>

<ul>
  <li>Heavyweight (heavy use of bandwidth during handshake)</li>
  <li>Designed around one-way, not mutual, authentication</li>
  <li>Non-confidential communication of identities during handshake</li>
  <li>Security session tied to connectivity session <ul><li>Having to re-run handshake every time underlying connection/IP changes compounds bandwidth problem</li></ul></li>
</ul>
<p id="rfc.section.1.4.1.p.2">(TODO) (1 list) what (D)TLS doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.4.2"><a href="#rfc.section.1.4.2">1.4.2.</a> <a href="#differences-from-quic" id="differences-from-quic">Differences from QUIC</a></h3>
<p/>

<ul>
  <li>Security session tied to connectivity session</li>
  <li>Not designed for mutual authentication</li>
</ul>
<p id="rfc.section.1.4.2.p.2">(TODO) (1 list) what QUIC doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.4.3"><a href="#rfc.section.1.4.3">1.4.3.</a> <a href="#differences-from-ikeipsec" id="differences-from-ikeipsec">Differences from IKE/IPSec</a></h3>
<p/>

<ul>
  <li>Pushing data requires performing full Two-Round-Trip handshake first</li>
  <li>Protects identity of server, not client, which is the opposite of what&#8217;s needed in IoT</li>
  <li>Very complex to configure, and easy to get wrong</li>
</ul>
<p id="rfc.section.1.4.3.p.2">(TODO) (1 list) what IKE doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.4.4"><a href="#rfc.section.1.4.4">1.4.4.</a> <a href="#differences-from-double-ratchet-based-protocols" id="differences-from-double-ratchet-based-protocols">Differences from Double-Ratchet-based Protocols</a></h3>
<p/>

<ul>
  <li>Per-message key updating is too heavy for most IoT, which doesn&#8217;t require per-message forward secrecy</li>
  <li>Doesn&#8217;t address identification (uses trust on first use)</li>
</ul>
<p id="rfc.section.1.4.4.p.2">(TODO) (1 list) what Double-Ratchet doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.4.5"><a href="#rfc.section.1.4.5">1.4.5.</a> <a href="#differences-from-noise" id="differences-from-noise">Differences from Noise</a></h3>
<p/>

<ul>
  <li>Designed mainly for either pre-shared (or statically-known) keys, or for unauthenticated communication</li>
</ul>
<p id="rfc.section.1.4.5.p.2">(TODO) (1 list) what Noise doesn&#8217;t offer that IoT requires</p>
<h3 id="rfc.section.1.4.6"><a href="#rfc.section.1.4.6">1.4.6.</a> <a href="#differences-from-minimalt" id="differences-from-minimalt">Differences from MinimaLT</a></h3>
<p/>

<ul>
  <li>Requires a highly-available directory service for name-lookup (unnecessary in IoT)</li>
  <li>Reliable-transport only (can cause issues on lossy networks commonly encountered in IoT)</li>
  <li>User-level authentication is inappropriate for IoT (devices aren&#8217;t multi-user)</li>
</ul>
<p id="rfc.section.1.4.6.p.2">(TODO) (1 list) what MinimalLT doesn&#8217;t offer that IoT requires</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.2.p.1">The XTT protocol provisions shared, secret state between a client and a server that may persist past the lifetime of the underlying connection.  This shared state is grouped into two classes:</p>
<p/>

<ul>
  <li>A long-term identity for a client and the shared secrets used to prove that identity to the server during future communication</li>
  <li>A session consisting of cryptographic material to be used for message authentication and confidentiality</li>
</ul>
<p id="rfc.section.2.p.3">A client requests an identity from a server using the handshake shown in (<a href="#xtt-provisioning">Figure 1</a>) and described in (<a href="#identity-provisioning-protocol">Section 3.2</a>).  To complete the handshake, the client must prove its membership in a client group recognized by the server, using a Direct Anonymous Attestation (DAA) signature.</p>
<div id="rfc.figure.1"/>
<div id="xtt-provisioning"/>
<pre>
        Client                                             Server
        -----------------------             -----------------------
         CLIENTINIT
         + version
         + suite_spec
         + nonce_c 
         + dh_keyshare_c         -------&gt;
                                             SERVERINITANDATTEST ^ &lt; Hk
                                                       version + | 
                                                    suite_spec + | 
                                                 dh_keyshare_s + | 
                                                 {certificate} + | 
                                                 {signature_s} + |
                                 &lt;-------      {server_cookie} + v 
  Hk &gt; ^ IDENTITY_CLIENTATTEST 
       | + version
       | + suite_spec
       | + server_cookie
       | + {daa_gpk}
       | + {id_c}
       v + {daa_signature_c}     -------&gt;
                                         IDENTITY_SERVERFINISHED ^ &lt; Hk
                                                       version + |
                                                    suite_spec + |
                                                        {id_c} + |
                                 &lt;-------    {awareness_proof} + v
  
              +    Indicates message subfields
              ()   Indicates optional messages/subfields
              {}   Indicates data encrypted using handshake keys
              Hk &gt; Indicates data MAC'd using handshake keys
</pre>
<p class="figure">Figure 1: Message flow for XTT Identity Provisioning Handshake</p>
<p id="rfc.section.2.p.4">Once a client possesses an identity, it authenticates that identity to a server and negotiates a session, using the handshake shown in (<a href="#xtt-session">Figure 2</a>) and described in (<a href="#session-establishment-protocol">Section 3.3</a>).  The cryptographic parameters and materials negotiated during the session-establishment handshake allow the client and server to protect (check authentication and integrity, and optionally encrypt) application layer traffic using a record-level protocol also shown in (<a href="#xtt-session">Figure 2</a>) and described in (<a href="#record-protocol">Section 4</a>).</p>
<div id="rfc.figure.2"/>
<div id="xtt-session"/>
<pre>
        Client                                             Server
        -----------------------             -----------------------
         CLIENTINIT
         + version
         + suite_spec
         + nonce_c 
         + dh_keyshare_c         -------&gt;
                                             SERVERINITANDATTEST ^ &lt; Hk
                                                       version + | 
                                                    suite_spec + | 
                                                 dh_keyshare_s + | 
                                                 {certificate} + | 
                                                 {signature_s} + |
                                 &lt;-------      {server_cookie} + v 
  Hk &gt; ^ SESSION_CLIENTATTEST 
       | + version
       | + suite_spec
       | + server_cookie
       | + {session_id}
       | + {id_c}
       v + {signature_c}
  Sk &gt; ^ (RECORDREGULAR)
       | + (version)
       | + (session_id)
       | + (seq_num)
       | + (length)
       | + ([payload_type])
       v + ([payload])           -------&gt;
                                          SESSION_SERVERFINISHED ^ &lt; Sk
                                                       version + |
                                                    suite_spec + |
                                                  {session_id} + |
                                 &lt;-------    {awareness_proof} + v

  Sk &gt; ^ RECORDREGULAR                             RECORDREGULAR ^ &lt; Sk
       | + version                                     version + |
       | + session_id                               session_id + |
       | + seq_num                                     seq_num + |
       | + length                                       length + |
       | + [payload_type]                       [payload_type] + |
       v + [payload]             &lt;------&gt;            [payload] + v
  
              +    Indicates message subfields
              ()   Indicates optional messages/subfields
              {}   Indicates data encrypted using handshake keys
              []   Indicates data encrypted using session keys
              Hk &gt; Indicates data MAC'd using handshake keys
              Sk &gt; Indicates data MAC'd using session keys
</pre>
<p class="figure">Figure 2: Message flow for XTT Session Creation Handshake and Record-Level Protocol</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#handshake-protocols" id="handshake-protocols">Handshake Protocols</a></h1>
<p id="rfc.section.3.p.1">The XTT protocol includes two handshake protocols: an identity-provisioning protocol, and a session-establishment protocol.</p>
<p id="rfc.section.3.p.2">The messages defined below are given to the underlying transport-layer as-is (i.e. there is no further framing).  A handshake MUST be completed within a single underlying connection with the same physical endpoint.</p>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#common-messages" id="common-messages">Common Messages</a></h2>
<p id="rfc.section.3.1.p.1">Both handshake protocols begin with the same two messages: the ClientInit and the ServerInitAndAttest.</p>
<h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#clientinit" id="clientinit">ClientInit</a></h3>
<p id="rfc.section.3.1.1.p.1">A client initiates a handshake with a ClientInit message.  This message determines the parameters (version and cryptographic algorithms) of the subsequent handshake, provides a nonce for the server to sign (to prevent replay attacks of this handshake), and communicates the client&#8217;s ephemeral Diffie-Hellman public key.</p>
<p id="rfc.section.3.1.1.p.2">Structure of this message:</p>
<pre>
struct {
    MsgType type = client_init;
    Version version;
    SuiteSpec suite_spec;
    SigningNonce nonce_c;
    DHKeyShare dh_keyshare_c;
} ClientInit;
</pre>
<h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#serverinitandattest" id="serverinitandattest">ServerInitAndAttest</a></h3>
<p id="rfc.section.3.1.2.p.1">Upon receiving a ClientInit message, and assuming the version and suite_spec are acceptable, a server responds with a ServerInitAndAttest message.  This message confirms the version and suite_spec, communicates the server&#8217;s ephemeral Diffie-Hellman public key, authenticates the server&#8217;s identity, and provides the client with a ServerCookie.  This ServerCookie is used to prevent replay attacks against the server, and to challenge the client&#8217;s return-routability.</p>
<p id="rfc.section.3.1.2.p.2">The ServerCookie also allows a server implementation to refrain from storing any local state until the client proves return-routability; see (<a href="#server-cookie-and-dos-attacks">Appendix D.2</a>).</p>
<p id="rfc.section.3.1.2.p.3">The message is AEAD-protected (using the algorithm specified in the suite_spec) using the <samp>server_handshake_send_key</samp> and <samp>server_handshake_send_iv</samp>.  The <samp>signature_s</samp> and <samp>certificate</samp> are created as described in (<a href="#serversignature">Section 6.6.1</a>).</p>
<p id="rfc.section.3.1.2.p.4">Structure of this message:</p>
<pre>
aead_struct&lt;server_handshake_send_keys&gt;(
    MsgType type = server_init_and_attest;
    Version version;
    SuiteSpec suite_spec;
    DHKeyShare dh_keyshare_s;
)[
    ServerCertificate certificate;
    ServerSignature signature_s;
    ServerCookie server_cookie;
] ServerInitAndAttest;
</pre>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#identity-provisioning-protocol" id="identity-provisioning-protocol">Identity Provisioning Protocol</a></h2>
<p id="rfc.section.3.2.p.1">This handshake provisions an identity to a client, along with the shared secrets necessary for the client to prove possesion of the identity.  A successful identity-provisioning handshake is required before a client may perform a session-establishment handshake.</p>
<h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#clientidentityclientattest" id="clientidentityclientattest">ClientIdentity_ClientAttest</a></h3>
<p id="rfc.section.3.2.1.p.1">Once a client receives a ServerInitAndAttest message during an identity-provisioning handshake, and assuming the ServerInitAndAttest is correctly validated (MAC and signature are verified, and version and suite_spec correspond to those sent in the ClientInit message), the client responds with a ClientIdentity_ClientAttest message.  This message echoes the ServerCookie (to prove return-reachability), authenticates the client&#8217;s membership in an authorized group, and requests to be provisioned an identity.</p>
<p id="rfc.section.3.2.1.p.2">A client may indicate a specific ClientID in the <samp>id_c</samp> field of a ClientIdentity_ClientAttest message, in order to request that specific ClientID be provisioned to it.  Otherwise, if the client wishes the server to select the ClientID for it, the <samp>id_c</samp> field MUST be set to all zeroes.</p>
<p id="rfc.section.3.2.1.p.3">The message is AEAD-protected (using the algorithm specified in the suite_spec) using the <samp>client_handshake_send_key</samp> and <samp>client_handshake_send_iv</samp>.  The <samp>daa_signature_c</samp> is created as described in (<a href="#daasignature">Section 6.6.3</a>).</p>
<p id="rfc.section.3.2.1.p.4">Structure of this message:</p>
<pre>
aead_struct&lt;client_handshake_send_keys&gt;(
    MsgType type =  MsgType.id_clientattest;
    Version version;
    SuiteSpec suite_spec;
    ServerCookie server_cookie;     /* echo from server */
}[
    DAAGroupKey daa_gpk;
    ClientID id_c;                  /* all zeroes if not specific id */
    DAASignature daa_signature_c;
] ClientIdentity_ClientAttest;
</pre>
<h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#clientidentityserverfinished" id="clientidentityserverfinished">ClientIdentity_ServerFinished</a></h3>
<p id="rfc.section.3.2.2.p.1">Once a server receives a ClientIdentity_ClientAttest message, and if that message is validated (message authentication code and client signature verified, and version and suite_spec are acceptable), the server responds with a ClientIdentity_ServerFinished message.</p>
<p id="rfc.section.3.2.2.p.2">The ClientIdentity_ServerFinished message informs the client of the ClientID that has been provisioned to it (either echoing the same <samp>id_c</samp> requested in the ClientAttest message or sending the newly-provisioned id if <samp>id_c</samp> was all zeroes).  In addition, the ServerFinished message contains a hash of the successful handshake, authenticated using a key derived from the LongtermSecret that has been provisioned.  This is to provide &#8216;peer-awareness&#8217; to the client, so the client and server can confirm they have the same view of the provisioned ClientID and LongtermSecret.</p>
<p id="rfc.section.3.2.2.p.3">The message is AEAD-protected (using the algorithm specified in the suite_spec) using the <samp>server_handshake_send_key</samp> and <samp>server_handshake_send_iv</samp>.  The <samp>awareness_proof</samp> is given by <samp>identity_awareness_proof</samp>, as described in (<a href="#xtt-psk-schedule">Figure 4</a>).</p>
<p id="rfc.section.3.2.2.p.4">Structure of this message:</p>
<pre>
aead_struct&lt;server_handshake_send_keys&gt;(
    MsgType type = MsgType.id_serverfinished;
    Version version;
    SuiteSpec suite_spec;
)[
    ClientID id_c;     /* confirm id of client */
    AwarenessProof awareness_proof;
] ClientIdentity_ServerFinished;
</pre>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#session-establishment-protocol" id="session-establishment-protocol">Session Establishment Protocol</a></h2>
<p id="rfc.section.3.3.p.1">This handshake negotiates a session (cryptographic secrets used for secure communication), and requires that a ClientID has been provisioned for this client via a previous identity-provisioning handshake.  A successful session-establishment handshake is required before a client may securely communicate via the record-layer protocol.</p>
<h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#sessionclientattest" id="sessionclientattest">Session_ClientAttest</a></h3>
<p id="rfc.section.3.3.1.p.1">Once a client receives a ServerInitAndAttest message during a session-establishment handshake, and assuming the ServerInitAndAttest is correctly validated (MAC and signature are verified, and version and suite_spec correspond to those sent in the ClientInit message), the client responds with a Session_ClientAttest message.  This message echoes the ServerCookie (to prove return-reachability), proves the client&#8217;s ownership of the claimed ClientID, and requests to be provisioned a SessionID.</p>
<p id="rfc.section.3.3.1.p.2">A client may indicate a specific SessionID in the <samp>session_id</samp> field of a ClientAttest message, in order to request that specific SessionID be provisioned to it.  Otherwise, if the client wishes the server to select the SessionID for it, the <samp>session_id</samp> field MUST be set to all zeroes.</p>
<p id="rfc.section.3.3.1.p.3">The message is AEAD-protected (using the algorithm specified in the suite_spec) using the <samp>client_handshake_send_key</samp> and <samp>client_handshake_send_iv</samp>.  The <samp>signature_c</samp> is created as described in (<a href="#symmetricsignature">Section 6.6.2</a>).</p>
<p id="rfc.section.3.3.1.p.4">Structure of this message:</p>
<pre>
aead_struct&lt;client_handshake_send_keys&gt;(
    MsgType type =  MsgType.session_clientattest;
    Version version;
    SuiteSpec spec;
    ServerCookie server_cookie;     /* echo from server */
}[
    SessionID session_id;           /* all zeroes if not specific id */
    ClientID id_c;                  /* from previous identity handshake */
    SymmetricSignature signature_c;
] Session_ClientAttest;
</pre>
<h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#sessionserverfinished" id="sessionserverfinished">Session_ServerFinished</a></h3>
<p id="rfc.section.3.3.2.p.1">Once a server receives a Session_ClientAttest message, and if that message is validated (message authentication code and client signature verified, and version and suite_spec are acceptable), the server responds with a Session_ServerFinished message.</p>
<p id="rfc.section.3.3.2.p.2">The Session_ServerFinished message informs the client of the SessionID that has been provisioned to it (either echoing the same <samp>session_id</samp> requested in the Session_ClientAttest message or sending the newly-provisioned SessionID if <samp>session_id</samp> was all zeroes).  In addition, the ServerFinished message contains a hash of the successful handshake, authenticated using a key derived from the cryptographic secrets that have been provisioned.  This is to provide &#8216;peer-awareness&#8217; to the client, so the client and server can confirm they have the same view of the provisioned secrets necessary for secure communication.</p>
<p id="rfc.section.3.3.2.p.3">The message is AEAD-protected (using the algorithm specified in the suite_spec) using the <samp>server_handshake_send_key</samp> and <samp>server_handshake_send_iv</samp>.  The <samp>awareness_proof</samp> is given by <samp>session_awareness_proof</samp>, as described in (<a href="#xtt-session-schedule">Figure 5</a>).</p>
<p id="rfc.section.3.3.2.p.4">Structure of this message:</p>
<pre>
aead_struct&lt;session_keys&gt;(
    MsgType type = MsgType.session_serverfinished;
    Version version;
    SuiteSpec spec;
)[
    SessionID session_id;   /* confirm session_id */
    AwarenessProof awareness_proof;
] Session_ServerFinished;
</pre>
<h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#behaviors-common-to-both-handshake-protocols" id="behaviors-common-to-both-handshake-protocols">Behaviors Common to Both Handshake Protocols</a></h2>
<p id="rfc.section.3.4.p.1">A client may resend a ClientInit if it has not received a ServerInitAndAttest in response within a timeout period.  There is no requirement that ClientInit retries be identical, as long as a client only responds to one ServerInitAndAttest response.</p>
<p id="rfc.section.3.4.p.2">When responding to a ClientInit message with a ServerInitAndAttest, a server MAY store all necessary state in the ServerCookie embedded in the ServerInitAndAttest and save no state locally.</p>
<p id="rfc.section.3.4.p.3">A server MAY respond to multiple ClientInit messages from the same client with not-necessarily identical ServerInitAndAttest messages before a full handshake is completed with that client.  However, if multiple ClientInitAndAttest replies are sent to the same client during a handshake and the server is storing state locally after responding (rather than storing state only in the ServerCookie), the server MUST ensure that response to any one of the ClientInitAndAttest is valid.</p>
<p id="rfc.section.3.4.p.4">If a client times-out waiting for a ServerFinished response to its ClientAttest message, the client MUST resend identical ClientAttest messages during the handshake, or else abort the handshake.  If multiple non-identical ClientAttest messages are sent during the same handshake, the client&#8217;s and the server&#8217;s view of the shared secret material negotiated during the handshake will differ, and communication will be impossible.</p>
<p id="rfc.section.3.4.p.5">A client MUST wait until successful receipt of a ServerFinished message before initiating a session-establishment handshake.</p>
<p id="rfc.section.3.4.p.6">If a server receives a ClientAttest message from a client from which it has already received a ClientAttest message during this handshake, the server MUST ignore the the extra messages.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#record-protocol" id="record-protocol">Record Protocol</a></h1>
<p id="rfc.section.4.p.1">(TODO): Describe record protocol</p>
<pre>
aead_struct&lt;session_keys&gt;(
    MsgType type = MsgType.record_regular;
    Version version;
    SessionID session_id;
    SequenceNumber seq_num;
    MsgLength length;
)[
    EncapsulatedPayloadType payload_type;
    byte payload[length - sizeof(rest_of_message)];
] Record_Regular;
</pre>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#error-handling" id="error-handling">Error Handling</a></h1>
<p id="rfc.section.5.p.1">(TODO)</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#cryptographic-computations" id="cryptographic-computations">Cryptographic Computations</a></h1>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#notation" id="notation">Notation</a></h2>
<p id="rfc.section.6.1.p.1">The cryptographic computations used in this protocol make use of a pseudo-random function <samp>prf</samp>, defined as:</p>
<pre>
prf&lt;N&gt;(Key, Input) =
    Keyed pseudo-random function (set during handshake),
    keyed by "Key", with "Input" as input, outputting "N" bytes
</pre>
<p id="rfc.section.6.1.p.2">The <samp>prf</samp> is implemented by a keyed hash function.  For the case of the SHA512-based suite_spec options, <samp>prf</samp> is HMAC, as specified in <a href="#RFC2104">[RFC2104]</a>, using SHA-512, defined in <a href="#SHS">[SHS]</a>, as the underlying hash function.  For the case of the BLAKE2b-based suite_spec options, <samp>prf</samp> is the BLAKE2b keyed-hash function, as defined in <a href="#RFC7693">[RFC7693]</a>.</p>
<p id="rfc.section.6.1.p.3">In addition, a non-keyed hash, denoted <samp>hash</samp>, will be referenced here.  For the SHA512-based suite_spec options, this is just SHA-512.  For the BLAKE2b-based suite_specs, this is Blake2b with a zero-length key.</p>
<p id="rfc.section.6.1.p.4">The hashes used in the cryptographic computations described below use a construction denoted <samp>hash_ext</samp>, which appends the input length to its input before hashing:</p>
<pre>
hash_ext(Input) =
    hash(
        struct {
            uint16 length = Input.length;
            byte input[&lt;input.length&gt;] = Input;
        };
    )
</pre>
<p id="rfc.section.6.1.p.5">Similarly, <samp>prf_ext</samp> is defined as the <samp>prf</samp> function with the output length appended to its input:</p>
<pre>
prf_ext&lt;N&gt;(Key, Input) =
    prf&lt;N&gt;(Key,
           struct {
               uint16 out_length = N;
               byte input[&lt;input.length&gt;] = Input;
           };
    )
</pre>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#transcript-hashes" id="transcript-hashes">Transcript Hashes</a></h2>
<p id="rfc.section.6.2.p.1">The computation of the shared secret materials requires various hashes of the handshake messages, in order to bind these secret materials to the specific handshake.  The definitions of these hash values follow below.</p>
<p id="rfc.section.6.2.p.2">When included in a hash, handshake messages are unencrypted.</p>
<pre>
ServerSigHash =
    hash_ext(
        ClientInit ||
        ServerInitAndAttest-up-to-signature
    )
</pre>
<pre>
HandshakeKeyHash =
    hash_ext(
        hash_ext(
            ClientInit ||
            ServerInitAndAttest-up-to-cookie
        ) ||
        server_cookie
    )
</pre>
<pre>
ClientSigHash =
    hash_ext(
        hash_ext(
            ClientInit ||
            ServerInitAndAttest-up-to-cookie
        ) ||
        server_cookie ||
        ClientAttest-up-to-signature
    )
</pre>
<pre>
SessionHash =
    hash_ext(
        hash_ext(
            ClientInit ||
            ServerInitAndAttest-up-to-cookie
        ) ||
        server_cookie ||
        ClientAttest
    )
</pre>
<pre>
ServerFinishedHash =
    hash_ext(
        hash_ext(
            ClientInit ||
            ServerInitAndAttest-up-to-cookie
        ) ||
        server_cookie ||
        ClientAttest ||
        ServerFinished-up-to-ctx
    )
</pre>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#key-calculation-and-schedule" id="key-calculation-and-schedule">Key Calculation and Schedule</a></h2>
<p id="rfc.section.6.3.p.1">Multiple secret materials are derived from the same input key by including different handshake context into the call to <samp>prf</samp>.  These contexts are defined in <a href="#xtt-context-table">Table 1</a> below, and their use is shown in <a href="#xtt-handshake-schedule">Figure 3</a>, <a href="#xtt-psk-schedule">Figure 4</a>, and <a href="#xtt-session-schedule">Figure 5</a>.</p>
<div id="rfc.table.1"/>
<div id="xtt-context-table"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Context Strings for Secret Material Derivation</caption>
  <thead>
    <tr>
      <th class="left">Context</th>
      <th class="right">Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">ClientHandshakeKeyContext</td>
      <td class="right">&#8220;XTT handshake client key&#8221; || HandshakeKeyHash</td>
    </tr>
    <tr>
      <td class="left">ClientHandshakeIVContext</td>
      <td class="right">&#8220;XTT handshake client iv&#8221; || HandshakeKeyHash</td>
    </tr>
    <tr>
      <td class="left">ServerHandshakeKeyContext</td>
      <td class="right">&#8220;XTT handshake server key&#8221; || HandshakeKeyHash</td>
    </tr>
    <tr>
      <td class="left">ServerHandshakeIVContext</td>
      <td class="right">&#8220;XTT handshake server iv&#8221; || HandshakeKeyHash</td>
    </tr>
    <tr>
      <td class="left">LongtermSharedSecretContext</td>
      <td class="right">&#8220;XTT long-term secret&#8221; || ServerFinishedHash</td>
    </tr>
    <tr>
      <td class="left">IdentityFinishedContext</td>
      <td class="right">&#8220;XTT identity awareness&#8221; || ServerFinishedHash</td>
    </tr>
    <tr>
      <td class="left">LongtermSecretKeyContext</td>
      <td class="right">&#8220;XTT long-term secret key&#8221; || ServerFinishedHash</td>
    </tr>
    <tr>
      <td class="left">ClientSessionKeyContext</td>
      <td class="right">&#8220;XTT session client key&#8221; || SessionHash</td>
    </tr>
    <tr>
      <td class="left">ClientSessionIVContext</td>
      <td class="right">&#8220;XTT session client iv&#8221; || SessionHash</td>
    </tr>
    <tr>
      <td class="left">ServerSessionKeyContext</td>
      <td class="right">&#8220;XTT session server key&#8221; || SessionHash</td>
    </tr>
    <tr>
      <td class="left">ServerSessionIVContext</td>
      <td class="right">&#8220;XTT session server iv&#8221; || SessionHash</td>
    </tr>
    <tr>
      <td class="left">SessionFinishedContext</td>
      <td class="right">&#8220;XTT session awareness&#8221; || SessionHash</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.3.p.2">The prf is drawn as taking the key argument from the left and outputting downward.  <samp>DH-shared-secret</samp> is the result of running Diffie-Hellman using the keys exchanged during the handshake, and <samp>key_size</samp> and <samp>iv_size</samp> are the key- and nonce-sizes (respectively) for the AEAD algorithm determined by the suite_spec.</p>
<div id="rfc.figure.3"/>
<div id="xtt-handshake-schedule"/>
<pre>
  (nonce_c | server_cookie)
     |      
     |      
     +--&gt; prf&lt;sizeof(LongtermSecret)&gt;(DH-shared-secret)
           |
           +--&gt; prf&lt;key_size&gt;(ClientHandshakeKeyContext)
           |     |
           |     +--&gt; client_handshake_send_key
           |     |
           |     +--&gt; server_handshake_receive_key
           |
           +--&gt; prf&lt;iv_size&gt;(ClientHandshakeIVContext)
           |     |
           |     +--&gt; client_handshake_send_iv
           |     |
           |     +--&gt; server_handshake_receive_iv
           |
           +--&gt; prf&lt;key_size&gt;(ServerHandshakeKeyContext)
           |     |
           |     +--&gt; client_handshake_receive_key
           |     |
           |     +--&gt; server_handshake_send_key
           |
           +--&gt; prf&lt;iv_size&gt;(ServerHandshakeIVContext)
           |     |
           |     +--&gt; client_handshake_receive_iv
           |     |
           |     +--&gt; server_handshake_send_iv
           |
           +--&gt; handshake_secret
</pre>
<p class="figure">Figure 3: Key Schedule for Handshake Keys</p>
<div id="rfc.figure.4"/>
<div id="xtt-psk-schedule"/>
<pre>
  handshake_secret
     |      
     |      
     +--&gt; prf&lt;sizeof(LongtermSecret)&gt;(ClientID)
           |
           +--&gt; prf&lt;sizeof(LongtermSecret)&gt;(LongtermSharedSecretContext)
           |     |
           |     +--&gt; longterm_client_shared_secret
           |
           +--&gt; prf&lt;sizeof(AwarenessProof)&gt;(IdentityFinishedContext)
           |     |
           |     +--&gt; identity_awareness_proof
           |
           +--&gt; prf&lt;sizeof(LongtermSignatureKey)&gt;(LongtermSecretKeyContext)
                 |
                 +--&gt; longterm_client_shared_secret_key
</pre>
<p class="figure">Figure 4: Derivation of Longterm-Shared-Secret</p>
<div id="rfc.figure.5"/>
<div id="xtt-session-schedule"/>
<pre>
  handshake_secret
     |      
     |      
     +--&gt; prf&lt;sizeof(LongtermSecret)&gt;(longterm_client_shared_secret)
           |
           +--&gt; prf&lt;key_size&gt;(ClientSessionKeyContext)
           |     |
           |     +--&gt; client_session_send_key
           |     |
           |     +--&gt; server_session_receive_key
           |
           +--&gt; prf&lt;iv_size&gt;(ClientSessionIVContext)
           |     |
           |     +--&gt; client_session_send_iv
           |     |
           |     +--&gt; server_session_receive_iv
           |
           +--&gt; prf&lt;key_size&gt;(ServerSessionKeyContext)
           |     |
           |     +--&gt; client_session_receive_key
           |     |
           |     +--&gt; server_session_send_key
           |
           +--&gt; prf&lt;iv_size&gt;(ServerSessionIVContext)
           |     |
           |     +--&gt; client_session_receive_iv
           |     |
           |     +--&gt; server_session_send_iv
           +--&gt; prf&lt;sizeof(AwarenessProof)&gt;(SessionFinishedContext)
                 |
                 +--&gt; session_awareness_proof
</pre>
<p class="figure">Figure 5: Key Schedule for Handshake Keys</p>
<h2 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#ecdhe-parameters" id="ecdhe-parameters">ECDHE Parameters</a></h2>
<p id="rfc.section.6.4.p.1">The size and interpretation of a value of type DHKeyShare depends on the Diffie-Hellman algorithm specified in the handshake messages.</p>
<p id="rfc.section.6.4.p.2">Currently, only x25519 is supported by the protocol.</p>
<p id="rfc.section.6.4.p.3">For x25519, the contents are the byte string inputs and outputs of the corresponding functions defined in <a href="#RFC7748">[RFC7748]</a>.  The size of the DHKeyShare in this case is 32 bytes.</p>
<h2 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#daa-parameters" id="daa-parameters">DAA Parameters</a></h2>
<p id="rfc.section.6.5.p.1">(TODO)</p>
<p id="rfc.section.6.5.p.2">EPID2, TPM2.0, and FIDO key/signature sizes.</p>
<h2 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#signature-algorithms" id="signature-algorithms">Signature Algorithms</a></h2>
<p id="rfc.section.6.6.p.1">The size and interpretation of signature types (signatures and public keys) depends on the signature algorithm.</p>
<h3 id="rfc.section.6.6.1"><a href="#rfc.section.6.6.1">6.6.1.</a> <a href="#serversignature" id="serversignature">ServerSignature</a></h3>
<p id="rfc.section.6.6.1.p.1">Currently, the only supported algorithm for the server&#8217;s signature in a ServerInitAndAttest is an EdDSA signature (described in <a href="#RFC8032">[RFC8032]</a>) using the X25519 elliptic curve (this combination is known as Ed25519).</p>
<p id="rfc.section.6.6.1.p.2">For Ed25519, the contents of ServerSignaturePublicKey are the byte string output of the key generation described in <a href="#RFC8032">[RFC8032]</a>, where the byte string format is defined in <a href="#RFC7748">[RFC7748]</a>.  Similarly, the content of ServerSignature are the byte string output of the signature algorithm of <a href="#RFC8032">[RFC8032]</a> in the format of <a href="#RFC7748">[RFC7748]</a>.</p>
<h3 id="rfc.section.6.6.2"><a href="#rfc.section.6.6.2">6.6.2.</a> <a href="#symmetricsignature" id="symmetricsignature">SymmetricSignature</a></h3>
<p id="rfc.section.6.6.2.p.1">(TODO)</p>
<h3 id="rfc.section.6.6.3"><a href="#rfc.section.6.6.3">6.6.3.</a> <a href="#daasignature" id="daasignature">DAASignature</a></h3>
<p id="rfc.section.6.6.3.p.1">(TODO)</p>
<h2 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a> <a href="#per-message-nonce-calculation" id="per-message-nonce-calculation">Per-message Nonce Calculation</a></h2>
<p id="rfc.section.6.7.p.1">A per-session pair of key and IV are created for both sending and receiving data, upon the successful completion of a handshake.  The client and server each get a pair of sending and receiving keys/IVs (of course, the server&#8217;s sending key/IV matches the client&#8217;s receiving key/IV, and vice-versa).  The byte-length of the IVs is that of the nonce for the negotiated AEAD algorithm.</p>
<p id="rfc.section.6.7.p.2">A per-message nonce is generated before AEAD encryption by left-padding the sequence number (in network byte order) to the length of the nonce/IV, then XOR&#8217;ing the appropriate IV with this padded sequence number.</p>
<p id="rfc.section.6.7.p.3">A server&#8217;s ServerInitAndAttest message has sequence number 0, and its ServerFinished message (either ClientIdentity_ServerFinished or Session_ServerFinished, depending on the type of handshake) has sequence number 1.  Similarly, a client&#8217;s ClientAttest message (either ClientIdentity_ClientAttest or Session_ClientAttest) has sequence number 0.</p>
<p id="rfc.section.6.7.p.4">At the start of a new session (after a successful handshake), the two sequence numbers (client-to-server and server-to-client) are reset to 0.  The first record-level payload the client sends after sending its Session_ClientAttest must have sequence number 0.  Similarly, the first record-level payload sent by the server after sending its Session_ServerFinished must have sequence number 0.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">Both XTT handshake protocols are based on the SigMA family of authenticated key exchange protocols, which is also the basis for signature-based authentication in the Internet Key Exchange version 2 (IKEv2) protocol <a href="#RFC7296">[RFC7296]</a> used in the IPSec protocol suite.  Specifically, the XTT protocol uses the SigMA-I variant described in <a href="#SIGMA">[SIGMA]</a>.  In particular, note that the present protocol does not place the MAC under the signature, as is done in IKEv2 (this is referred to as variant (ii) in <a href="#SIGMA">[SIGMA]</a>).  A formal security analysis of the SigMA protocols can be found in <a href="#SIGMASEC">[SIGMASEC]</a>.</p>
<p id="rfc.section.7.p.2">The handshake protocols are authenticated Diffie-Hellman key exchanges.  Both protocols require four messages.  The server, who is always the responder in a handshake, sends the final message to provide the client &#8220;peer awareness&#8221; (proving to the client that the server is alive and agrees on the results of the handshake).  The client, who is always the initiator of a handshake, may choose to begin pushing traffic with the third message of a session-establishment handshake, before receiving the peer awareness response from the server.  The reason for requiring a full roundtrip before application traffic is allowed (in contrast to the 0-RTT option proposed for the upcoming TLSv1.3 standard) is to protect against replay attacks.</p>
<p id="rfc.section.7.p.3">The handshake protocol protects the confidentiality of the client&#8217;s identity from both passive and active attackers, while protecting the server&#8217;s identity from passive attackers; in IoT, client identities are more likely to be sensitive than server identities.  Assuming at least one side (client or server) produces new Diffie-Hellman key pairs for each handshake, the protocol also provides forward secrecy.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2104">[RFC2104]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5869">[RFC5869]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7539">[RFC7539]</b>
      </td>
      <td class="top"><a>Nir, Y.</a> and <a>A. Langley</a>, "<a href="http://tools.ietf.org/html/rfc7539">ChaCha20 and Poly1305 for IETF Protocols</a>", RFC 7539, DOI 10.17487/RFC7539, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7693">[RFC7693]</b>
      </td>
      <td class="top"><a>Saarinen, M-J.</a> and <a>J-P. Aumasson</a>, "<a href="http://tools.ietf.org/html/rfc7693">The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)</a>", RFC 7693, DOI 10.17487/RFC7693, November 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7748">[RFC7748]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="http://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC8032">[RFC8032]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="http://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SHS">[SHS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology</a>, "<a>Secure Hash Standard</a>", NIST FIPS PUB 180-4, March 2012.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="DAA">[DAA]</b>
      </td>
      <td class="top"><a>Brickell, E.</a>, <a>Camenisch, J.</a> and <a>L. Chen</a>, "<a>Direct Anonymous Attestation</a>", Proceedings of the 11th ACM conference on Computer and communications security , February 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="MINIMALT">[MINIMALT]</b>
      </td>
      <td class="top"><a>Petullo, W.</a>, <a>Zhang, X.</a>, <a>Solworth, J.</a>, <a>Bernstein, D.</a> and <a>T. Lange</a>, "<a>MinimalLT: Minimal-latency Networking Through Better Security</a>", November 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7296">[RFC7296]</b>
      </td>
      <td class="top"><a>Kaufman, C.</a>, <a>Hoffman, P.</a>, <a>Nir, Y.</a>, <a>Eronen, P.</a> and <a>T. Kivinen</a>, "<a href="http://tools.ietf.org/html/rfc7296">Internet Key Exchange Protocol Version 2 (IKEv2)</a>", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SIGMA">[SIGMA]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, "<a>SIGMA: the 'SIGn-and-MAc' approach to authenticated Diffie-Hellman and its use in the IKE protocols</a>", Proceedings of CRYPTO 2003 , June 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SIGMASEC">[SIGMASEC]</b>
      </td>
      <td class="top"><a>Canetti, R.</a> and <a>H. Krawczyk</a>, "<a>Security Analysis of IKE's Signature-Based Key-Exchange Protocol</a>", October 2002.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#state-machine" id="state-machine">State Machine</a></h1>
<p id="rfc.section.A.p.1">This section provides a summary of the legal state machine transitions for the client and server handshakes.  State names (in all capitals, e.g., START) have no formal meaning, but are provided for ease of comprehension. Messages which are sent only sometimes are indicated in <samp>[]</samp>.  (TODO)</p>
<h2 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> <a href="#identity-provisioning-handshake" id="identity-provisioning-handshake">Identity Provisioning Handshake</a></h2>
<h3 id="rfc.appendix.A.1.1"><a href="#rfc.appendix.A.1.1">A.1.1.</a> <a href="#client" id="client">Client</a></h3>
<p id="rfc.section.A.1.1.p.1">(TODO)</p>
<h3 id="rfc.appendix.A.1.2"><a href="#rfc.appendix.A.1.2">A.1.2.</a> <a href="#server" id="server">Server</a></h3>
<p id="rfc.section.A.1.2.p.1">(TODO)</p>
<h2 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> <a href="#session-establishment-handshake" id="session-establishment-handshake">Session Establishment Handshake</a></h2>
<h3 id="rfc.appendix.A.2.1"><a href="#rfc.appendix.A.2.1">A.2.1.</a> <a href="#client-1" id="client-1">Client</a></h3>
<p id="rfc.section.A.2.1.p.1">(TODO)</p>
<h3 id="rfc.appendix.A.2.2"><a href="#rfc.appendix.A.2.2">A.2.2.</a> <a href="#server-1" id="server-1">Server</a></h3>
<p id="rfc.section.A.2.2.p.1">(TODO)</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#presentation-language" id="presentation-language">Presentation Language</a></h1>
<h2 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> <a href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h2>
<p id="rfc.section.B.1.p.1">Comments begin with <samp>/\*</samp> and end with <samp>\*/</samp>.  Concatenation of byte strings is denoted <samp>||</samp></p>
<p id="rfc.section.B.1.p.2">To indicate the number of bytes taken up in the byte stream by a type or value, the expression <samp>sizeof(value-or-type)</samp> is used.</p>
<p id="rfc.section.B.1.p.3">Optional components are denoted by enclosing them in <samp>[[ ]]</samp> double brackets.</p>
<h2 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> <a href="#definition-of-byte" id="definition-of-byte">Definition of Byte</a></h2>
<p id="rfc.section.B.2.p.1">One byte is defined to be 8 bits.  Multiple-byte data items are concatenations of bytes, from left to right, from top to bottom.</p>
<h2 id="rfc.appendix.B.3"><a href="#rfc.appendix.B.3">B.3.</a> <a href="#byte-arrays" id="byte-arrays">Byte Arrays</a></h2>
<p id="rfc.section.B.3.p.1">A byte-array is a single-dimensional array of bytes of given fixed length.  The syntax for specifying a new type, <samp>Tp</samp>, that is a byte-array of length <samp>n</samp> is</p>
<pre>
byte Tp[n];
</pre>
<p id="rfc.section.B.3.p.2">Here, <samp>Tp</samp> occupies <samp>n</samp> bytes in the data stream.  The length of the vector is not included in the encoded stream.</p>
<p id="rfc.section.B.3.p.3">An anonymous byte array is specified by not including a new type name: <samp>byte[n]</samp> indicates space of n bytes in the byte stream.  This is useful for constructed and variant types.</p>
<p id="rfc.section.B.3.p.4">Unless defined as a numeric data type, the bytes comprising a byte-array are not to be interpreted by the protocol in any way.</p>
<h2 id="rfc.appendix.B.4"><a href="#rfc.appendix.B.4">B.4.</a> <a href="#numeric-data" id="numeric-data">Numeric Data</a></h2>
<p id="rfc.section.B.4.p.1">A type defined as an n-byte numeric value indicates that the byte stream is interpreted (using C notation) as:</p>
<pre>
numeric_value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
        ... | byte[n-1];
</pre>
<p id="rfc.section.B.4.p.2">This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.  The pre-defined numeric types uint8, uint16, uint32, and uint64 are defined as</p>
<pre>
byte uint8[1];
byte uint16[2];
byte uint32[4];
byte uint64[8];
</pre>
<p id="rfc.section.B.4.p.3">For example, the uint32 value given by the bytestream <samp>01 02 03 04</samp> is interpreted as the decimal value 16909060.</p>
<h2 id="rfc.appendix.B.5"><a href="#rfc.appendix.B.5">B.5.</a> <a href="#enumerateds" id="enumerateds">Enumerateds</a></h2>
<p id="rfc.section.B.5.p.1">To indicate a type that may take values only from a fixed set of possible values, a new type may be defined as of type <samp>enum</samp>.  Each definition of an enumerated type is a different type.  Only enumerateds of the same type may be assigned or compared.  Every element of an enumerated must be assigned a value.</p>
<p id="rfc.section.B.5.p.2">The possible values of an enumerated type are specified in this document using numeric values.  To indicate how to interpret a value of an enumerated type, and to indicate how much space in the byte stream is occupied by an enumerated type, the definition of the enumerated type includes the underlying numeric type used to define its values.</p>
<p id="rfc.section.B.5.p.3">Implementations that receive a value of an enumerated type that is not in the set of possible values for that type MUST reject the containing message and handle the error as specified for that message type.</p>
<p id="rfc.section.B.5.p.4">The following example defines an enumerated type called Color that has three possible values, which are represented in the byte stream as uint16 values (thus a value of type Color occupies 2 bytes in the byte stream)</p>
<pre>
enum : uint16 {
    Red(0x1234),
    Green(9),
    Blue(60000)
} Color;
</pre>
<p id="rfc.section.B.5.p.5">The names of the elements of an enumerated type are scoped within the defined type, and a reference in this document to the value of a name is always given by the fully-qualified form <samp>Type.Name</samp>.  Thus a reference to the <samp>Color</samp> value <samp>Blue</samp> from above is given by <samp>Color.Blue</samp>.</p>
<h2 id="rfc.appendix.B.6"><a href="#rfc.appendix.B.6">B.6.</a> <a href="#constructed-types" id="constructed-types">Constructed Types</a></h2>
<p id="rfc.section.B.6.p.1">Complex types may be constructed from primitive types, using the <samp>struct</samp> construction.  Each constructed type defines a new type.</p>
<p id="rfc.section.B.6.p.2">The following example defines a constructed type called <samp>T</samp>, which comprises two subfields <samp>f1</samp> and <samp>f2</samp></p>
<pre>
struct {
    T1 f1;
    T2 f2;
} T;
</pre>
<p id="rfc.section.B.6.p.3">A value of type <samp>T</samp> would occupy a total of <samp>sizeof(T1) + sizeof(T2)</samp> bytes in the byte stream.</p>
<p id="rfc.section.B.6.p.4">Subfields of a constructed type are referenced in this document by <samp>Type.subfield</samp> when referring to the field in the general type <samp>Type</samp>, and by <samp>name.subfield</samp> when referring to the field in a specific value named <samp>name</samp>.  Thus, the value of the subfield <samp>f2</samp> in a value called <samp>foo</samp> of type <samp>T</samp>, from the example above, would be referenced as <samp>foo.f1</samp>.</p>
<h2 id="rfc.appendix.B.7"><a href="#rfc.appendix.B.7">B.7.</a> <a href="#aead-encrypted-constructed-types" id="aead-encrypted-constructed-types">AEAD-Encrypted Constructed Types</a></h2>
<p id="rfc.section.B.7.p.1">Encryption and authentication of all messages in this protocol are done using Authenticated Encryption with Additional Data (AEAD) <a href="#RFC5116">[RFC5116]</a>.  To indicate that a constructed type is processed using an AEAD algorithm, the following notation is used:</p>
<pre>
aead_struct&lt;key_set&gt;(
    addl1;
    addl2;
    ...
    addlN;
)[
    enc1;
    enc2;
    ...
    encN;
] T;
</pre>
<p id="rfc.section.B.7.p.2">In this example, the type <samp>T</samp> consists of the unencrypted subfields <samp>addl1</samp> through <samp>addlN</samp>, and the encrypted subfields <samp>enc1</samp> through <samp>encN</samp>.  The keys (encryption key, authentication key, and nonce) used is given by <samp>key_set</samp>.  The entire struct is authenticated.  Note that the total length in the byte stream of a value of type <samp>T</samp> is the size of an authentication tag (determined by the chosen AEAD algorithm) in addition to the sum of the sizes of its subfields.</p>
<h2 id="rfc.appendix.B.8"><a href="#rfc.appendix.B.8">B.8.</a> <a href="#constants" id="constants">Constants</a></h2>
<p id="rfc.section.B.8.p.1">Fields and variables may be assigned a fixed value using <samp>=</samp>.  In the following example, all values of type <samp>T</samp> would always have <samp>T.c</samp> equal to <samp>Color.Blue</samp></p>
<pre>
struct {
    Color c = Color.Blue;
    T2 f2;
} T;
</pre>
<h2 id="rfc.appendix.B.9"><a href="#rfc.appendix.B.9">B.9.</a> <a href="#variants" id="variants">Variants</a></h2>
<p id="rfc.section.B.9.p.1">Defined structures may have variants based on some knowledge that is available within the environment.  The selector must be an enumerated type that defines the possible variants the structure defines.  There must be a case arm for every element of the enumeration declared in the select.  Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields.</p>
<p id="rfc.section.B.9.p.2">The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.</p>
<p id="rfc.section.B.9.p.3">For example:</p>
<pre>
uint8 SubT1;
uint16 SubT2;
struct {
    select (color_in) {
        case Color.Red:
            SubT1;
        case Color.Green:
        case Color.Blue:
            SubT2;
    } variant_field;
} VariantStruct;
</pre>
<p id="rfc.section.B.9.p.4">In this example, it is assumed the creation of a value of type <samp>VariantStruct</samp> requires the input of a parameter called <samp>color_in</samp> of type <samp>Color</samp>.  When creating a value of type VariantStruct with name S, if <samp>color_in</samp> is <samp>Red</samp> then the subfield <samp>S.variant_field</samp> is of type <samp>SubT1</samp>.  Alternatively, if <samp>color_in</samp> is either <samp>Green</samp> or <samp>Blue</samp>, <samp>S.variant_field</samp> is of type <samp>SubT2</samp>.  Note that the size of the type <samp>VariantStruct</samp> depends on the value of <samp>color_in</samp> at the time of construction.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#protocol-data-structures-and-constant-values" id="protocol-data-structures-and-constant-values">Protocol Data Structures and Constant Values</a></h1>
<p id="rfc.section.C.p.1">This section describes protocol types and constants.</p>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#common-message-header" id="common-message-header">Common Message Header</a></h2>
<pre>
enum : uint8 {
    client_identity_client_init(0x11),
    client_identity_server_init_and_attest(0x12),
    id_clientattest_nopayload(0x13),
    id_clientattest_payload(0x14),
    id_serverfinished(0x15),
    session_client_init(0x21),
    session_server_init_and_attest(0x22),
    session_clientattest_nopayload(0x23),
    session_clientattest_payload(0x24),
    session_serverfinished(0x25),
    record_regular(0x31),
    alert(0x41)
} MsgType;
</pre>
<pre>
enum : uint8 {
    one(1)
} Version;
</pre>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#handshakes" id="handshakes">Handshakes</a></h2>
<pre>
enum : uint16 {
    x25519_epid2_ed25519_chacha20poly1305_sha512(1),
    x25519_epid2_ed25519_chacha20poly1305_blake2b(2),
    x25519_epid2_ed25519_aes256gcm_sha512(3),
    x25519_epid2_ed25519_aes256gcm_blake2b(4),
    x25519_epid2_ed25519_null_sha512(5),
    x25519_epid2_ed25519_null_blake2b(6)
} SuiteSpec;
</pre>
<pre>
byte SigningNonce[32];
</pre>
<pre>
byte ServerCookie[130];
</pre>
<pre>
byte ClientID[16];
</pre>
<pre>
byte LongtermSecret[64];
</pre>
<pre>
byte AwarenessProof[16];
</pre>
<pre>
byte DHKeyShare[&lt;size of public key for this algorithm&gt;];
</pre>
<h3 id="rfc.appendix.C.2.1"><a href="#rfc.appendix.C.2.1">C.2.1.</a> <a href="#signature-types" id="signature-types">Signature Types</a></h3>
<pre>
byte SymmetricSignature[&lt;size of prf output&gt;];
</pre>
<pre>
byte SymmetricSignatureKey[64];
</pre>
<pre>
byte ServerSignature[&lt;size of signature for this algorithm&gt;];
</pre>
<pre>
byte ServerSignaturePublicKey[&lt;size of public key for this algorithm&gt;];
</pre>
<pre>
byte DAAGroupKey[&lt;size of group public key for this algorithm&gt;];
</pre>
<pre>
byte DAASignature[&lt;size of signature for this algorithm&gt;];
</pre>
<h3 id="rfc.appendix.C.2.2"><a href="#rfc.appendix.C.2.2">C.2.2.</a> <a href="#server-certificates" id="server-certificates">Server Certificates</a></h3>
<pre>
enum : uint8 {
    one(1)
} ServerCertificateVersion;
</pre>
<pre>
byte Date[8];   /* YYYYMMDD according to UTC */
</pre>
<pre>
struct {
    ServerCertificateVersion version;
    Date expiry;
    ClientID id;
    ServerSignaturePublicKey public_key;
    ServerIntermediateCertificate signers_certificate;
    ServerSignature signers_signature;
} ServerCertificate;
</pre>
<pre>
struct {
    ServerSignatureVersion version;
    Date expiry;
    ServerSignaturePublicKey public_key;
    byte root_id[32];       /* ServerRootCertificate to use */
    ServerSignature root_signature;
} ServerIntermediateCertificate;
</pre>
<pre>
struct {
    ServerSignatureVersion version;
    Date expiry;
    ServerSignaturePublicKey public_key;
    byte id[32];
} ServerRootCertificate;
</pre>
<h2 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> <a href="#record-layer" id="record-layer">Record Layer</a></h2>
<pre>
byte SessionID[16];
</pre>
<pre>
uint32 SequenceNumber;
</pre>
<pre>
uint16 MsgLength;
</pre>
<pre>
enum : uint8 {
    queue_protocol(1),
    ipv6(2)
} EncapsulatedPayloadType;
</pre>
<h1 id="rfc.appendix.D"><a href="#rfc.appendix.D">Appendix D.</a> <a href="#implementation-notes" id="implementation-notes">Implementation Notes</a></h1>
<h2 id="rfc.appendix.D.1"><a href="#rfc.appendix.D.1">D.1.</a> <a href="#distributed-servers-and-proxies" id="distributed-servers-and-proxies">Distributed Servers and Proxies</a></h2>
<p id="rfc.section.D.1.p.1">Because the identity and session may be long-lived and are not tied to the underlying network connection, the protocol makes no requirement that a client only communicate with a single physical server endpoint during the lifetime of an identity or session.  A common use case is of multiple server endpoints that share long-term storage, all aware of the state shared with a client endpoint.</p>
<p id="rfc.section.D.1.p.2">Similarly, the protocol makes no requirement that the physical endpoint that completes the identity-provisioning handshake be the same physical endpoint to which this identity is given.  For example, a proxy capable of producing DAA signatures may request multiple distinct identities for the distinct endpoints behind it.</p>
<h2 id="rfc.appendix.D.2"><a href="#rfc.appendix.D.2">D.2.</a> <a href="#server-cookie-and-dos-attacks" id="server-cookie-and-dos-attacks">Server Cookie and DoS Attacks</a></h2>
<p id="rfc.section.D.2.p.1">Server implementation MAY refrain from storing local state after responding to a ClientInit, and instead store state in the ServerCookie.  Either way, the implementation MUST have a means of authenticating an ServerCookie echoed back to a server as being generated by that server and of checking that the ServerCookie has not been seen by that server before.  One possible implementation of this is to AEAD encrypt the cookie with a key known only to the server and rotated frequently: upon receiving a cookie, the server checks that the cookie can be decrypted with a recent key, proving authenticity and freshness, and remembering that cookie has having been seen (only cookies generated using the recent key need be remembered), proving uniqueness.</p>
<h2 id="rfc.appendix.D.3"><a href="#rfc.appendix.D.3">D.3.</a> <a href="#underlying-transport-protocol" id="underlying-transport-protocol">Underlying Transport Protocol</a></h2>
<p id="rfc.section.D.3.p.1">(TODO) Notes on fragmenting, ordering, etc.</p>
<h2 id="rfc.appendix.D.4"><a href="#rfc.appendix.D.4">D.4.</a> <a href="#cryptographic-requirements" id="cryptographic-requirements">Cryptographic Requirements</a></h2>
<p id="rfc.section.D.4.p.1">(TODO) Requirements for identity-provisioning handshake, for session-establishment handshake, and for record-level communication.</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Zane Beckwith</span> 
	  <span class="n hidden">
		<span class="family-name">Beckwith</span>
	  </span>
	</span>
	<span class="org vcardline">Xaptum, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:zane.beckwith@xaptum.com">zane.beckwith@xaptum.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David R. Bild</span> 
	  <span class="n hidden">
		<span class="family-name">Bild</span>
	  </span>
	</span>
	<span class="org vcardline">Xaptum, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:david.bild@xaptum.com">david.bild@xaptum.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/xaptum/xtt-spec">Fork me on GitHub</a></div></div>
</body>
</html>
